
#include "internal.h"

#include "../terminal/terminal/v938/driver/basefunc/vregdef938.h"



static const TRegUnit cpmReg[] =
{
	{ V938_REGTYPE, "V9_REG_PAGE0_PMCTRL", V9_REG_PAGE0_PMCTRL, 0, 0, "PR2 power management control\nBit2: reg_pwdb(for 1.8v output);\nBit1: iref_pwdb(for current bias);\nBit0: vref_pwdb(for bandgap)" },
	{ V938_REGTYPE, "V9_REG_PA¡¯GE0_PACFG", V9_REG_PAGE0_PACFG, 0,0, "Bit7: SP_PWD, active high;\nBit6: SPMUTE, active high;\nBit5: Reserved;\nBit4: OT_PROTPA over temperature protection enable, active high\nBit3: POP_CANCEL Pop Noise Suppression enable, active high\nBit2: CUR_PROT\nPA current protection enable, active high\nBit1: FASTON_EN, active high;Bit0: SLOWOFF_EN, active high" },
	{ V938_REGTYPE, "V9_REG_PAGE0_DACCFG", V9_REG_PAGE0_DACCFG, 0, 0,"On chip DAC configure registerBit7: reserved;Bit6: DAC_DATA_SRC	1¡¯\nb0: from on chip I2S master(after Wave Engine);\n1¡¯b1: from off chip I2S master;\nBit5- Bit 4: On-chip DAC_MCLK_FRQ	\n2¡¯b00: Fs*128;	2¡¯b01:Fs*256;	2¡¯b10:Fs*384;		2¡¯b11:Fs*512    ;\nOnly Fs*256 is supported in this chip.\nBit3- Bit0: reserved"},
	{ V938_REGTYPE, "V9_REG_PAGE0_SPVOL_CTL", V9_REG_PAGE0_SPVOL_CTL, 0, 0,"Spvol controller register;\nBit1: update instant;\nBit2: saddow read enable;Bit2: update test;Others: reserved" },
	{ V938_REGTYPE, "V9_REG_PAGE0_DACCTRL", V9_REG_PAGE0_DACCTRL, 0, 0,"Bit7: TEST, active high, must be set to 0 in working mode\n;Bit6: DEEPTH, active high\nBit5- Bit 4: IOWL,choose of the word length between 24/20/18/16bit;\nBit3: NRST, active low;Bit2: SB, active high;Bit1: SB_DAC, active high;Bit0: Mute, active high" },
	{ V938_REGTYPE, "V9_REG_PAGE0_SPVOL", V9_REG_PAGE0_SPVOL, 0, 0, "Bit3- Bit 0:Speaker amplify volume control\n	0000B: -18DB	¡­	1001B: 0DB	¡­	1111B: 12DB;Bit7- Bit 4: Reserved"},
	{ V938_REGTYPE, "V9_REG_PAGE0_TEST_O", V9_REG_PAGE0_TEST_O, 0, 0, "Bit7- Bit 4: reserved to 0;\nBit4: VOL_CHNG;\nBit3: PA_SHORT_I;\nBit2: PA_OVER_T;\nBit1: DAC_ODMODL;\nBit0: DAC_ODMODR"},
	{ V938_REGTYPE, "V9_REG_PAGE0_STRAP", V9_REG_PAGE0_STRAP, 0, 0,"These registers latch data from P0 during and after \npower on reset in this duration the P0 serve as \nGPIO in open drain mode with pull-up/down resistor enable, \nand can¡¯t be changed by SW.\nBit7-0: To be defined by custom"},
	{ V938_REGTYPE, "V9_REG_PAGE0_CINFO_REN_ADD", V9_REG_PAGE0_CINFO_REN_ADD, 0, 0,"Chip info pull up resistor control register, active low\nBit7- Bit 2: reserved;\nBit1: CINFO[1] pull up resister control bit:\n 1¡¯b0: pull up enable,\n1¡¯b1: pull up disable\nBit0: CINFO[0] pull up resister control bit :\n 1¡¯b0: pull up enable,\n1¡¯b1: pull up disable"},
	{ V938_REGTYPE, "V9_REG_PAGE0_CINFO_ADD", V9_REG_PAGE0_CINFO_ADD, 0, 0,"Chip info\nBit7-Bit2:	Reserved,Bit1- Bit 0: 	CINFO[1:0]"},
	{ V938_REGTYPE, "V9_REG_PAGE0_DUMMY_REG0", V9_REG_PAGE0_DUMMY_REG0, 0, 0 },
	{ V938_REGTYPE, "V9_REG_PAGE0_DUMMY_REG1", V9_REG_PAGE0_DUMMY_REG1, 0, 0 },
	{ V938_REGTYPE, "V9_REG_PAGE0_DUMMY_REG2", V9_REG_PAGE0_DUMMY_REG2, 0, 0 },
	{ V938_REGTYPE, "V9_REG_PAGE0_DUMMY_REG3", V9_REG_PAGE0_DUMMY_REG3, 0, 0 },
	{ V938_REGTYPE, "V9_REG_PAGE0_MISC_CON", V9_REG_PAGE0_MISC_CON, 0, 0,"Bit0: SEL_ASYN_SYN\n1¡¯b0: Asynchronous type\n1¡¯b1: Synchronous type\nBit1: Enable data output to external I2S receiver;\nBit2: SLEEP, active high,\nWhen it active, all the I/O pin will be put intoinput mode,\nt must be set to ¡°0¡± before you want to operate chip e.g. read register;\nBit7- Bit 3: Reserved." },
	{ V938_REGTYPE, "V9_REG_PAGE0_I2SCFG", V9_REG_PAGE0_I2SCFG, 0, 0,"I2S configure register include clock configure and mode configure\nBit0: i2s_sclk_poly:1¡¯b0: normal;1¡¯b1: inverted;\nBit1: i2s_mck_dir:\nWhich is active only when DAC_CON[6]=1\n,1¡¯b0: from eternal I2S;1¡¯b1:output MCK to external I2S;\nBit2: i2s_mode,control the PAD sharing for different system configuration.\n1¡¯b0: slave mode, VC0938 is an I2S receiver\n1¡¯b1: master mode, VC0938 is an I2S transmitter;\nBit3: Reserved;\nBit5- Bit 4: Divider3 control:\nWhich is active only when DAC_CON[6]=1(DAC_DATA_SRC);\nBit7- Bit 6: Divider2 control:\nWhich is active only when DAC_CON[6]=0(DAC_DATA_SRC);" },
	{ V938_REGTYPE, "V9_REG_PAGE0_FUNC_SEL", V9_REG_PAGE0_FUNC_SEL, 0, 0,"Select GPIO P0 function when GPIO\ncorresponding bit is in functionmode( GPIO_CFG[n]=1¡¯b0)\nBit3-Bit0:4¡¯b0000: P0[3]-P0[0] in PIO mode\n4¡¯b0001: P0[3]-P0[0] server as Led and MTR\noutput:4¡¯b0010: P0[3]-P0[0] serve as I2S interface\n4¡¯b0100: Res.\n4¡¯b1000: P0[3]-P0[0] serve as PA test output.\nOthers:  Res.\nBit7- Bit 4:  Res." },
	{ V938_REGTYPE, "V9_REG_PAGE0_SRD", V9_REG_PAGE0_SRD, 0, 0,"Serial read port" },
	{ V938_REGTYPE, "V9_REG_PAGE0_UM_CTRL", V9_REG_PAGE0_UM_CTRL, 0, 0,"UMonitor control, which is used for test only\nBit3- Bit 0: module group select\nBit6- Bit 4: module select\nBit7: UM_enable active high" },
	{ V938_REGTYPE, "V9_REG_PAGE0_GPIO_CFG", V9_REG_PAGE0_GPIO_CFG, 0, 0,"GPIO configure register:\n1¡¯b0: GPIO mode disable\n1¡¯b1: GPIO mode enable\nBit 0: GPIO00/External LED1 control/ Master or Slave I2S main clock\nBit 1: GPIO01/External LED2 control / Master or Slave I2S sample clock\nBit 2: GPIO02/External LED3 control	/ Master or Slave I2S WS\nBit 3: GPIO03/External motor control 	/ Master or Slave I2S SD" },
	{ V938_REGTYPE, "V9_REG_PAGE0_P0_MODE", V9_REG_PAGE0_P0_MODE, 0, 0,"GPIO P0 work mode,bit actively\n1¡¯b0: open drain mode\n1¡¯b1: PIO mode" },
	{ V938_REGTYPE, "V9_REG_PAGE0_P0_DIR", V9_REG_PAGE0_P0_DIR, 0, 0,"It only take effect when the corresponding bit of \np0_mode is set to high\n1¡¯b0: input mode\n1¡¯b1: output mode" },
	{ V938_REGTYPE, "V9_REG_PAGE0_PORT0", V9_REG_PAGE0_PORT0, 0, 0,"Port 0: the read back value if from PAD\nGPIO[7:0]" },
	{ V938_REGTYPE, "V9_REG_PAGE0_D_REN", V9_REG_PAGE0_D_REN, 0, 0,"Data bus output pull-up control:\n1¡¯b0: enable;\n1¡¯b1: disable" },
	{ V938_REGTYPE, "V9_REG_PAGE0_GPIO_REN", V9_REG_PAGE0_GPIO_REN, 0, 0,"Gpio output pull-up control: \n1¡¯b0: enable;\n1¡¯b1: disable" },
	{ V938_REGTYPE, "V9_REG_PAGE0_MISC_TEST", V9_REG_PAGE0_MISC_TEST, 0, 0,"Bit7- Bit 0: reserved" },
	{ V938_REGTYPE, "V9_REG_PAGE0_CLKCTRL0", V9_REG_PAGE0_CLKCTRL0, 0, 0,"Control PLL and clock input. Only reset by HW reset.\nBit0: CLKGT0: gate FIN to PLL, active high\nBit1: CLKGT1: gate MCLK all, active high\nBit2: CLKGT2: gate dac_mck, active high\nBit3: CLKGT3: gate i2s_mck to external I2S RCV\nBit4: CLKRST, active high, reset the clock\ngenerator module, have no effect on CCLK( busclock),\nBit5:PLL output enable, active low;\nBit6: PLL bypass mode, active high;\nBit7: PLL power down, active high" },
	{ V938_REGTYPE, "V9_REG_PAGE0_CLKCTRL1", V9_REG_PAGE0_CLKCTRL1, 0, 0,"Control PLL and clock input. Only reset by HW reset.\nBit4- Bit 0: R[4:0]:The input 5-bit divider control pin;\nBit5: CHNR: PLL choose the input divider;\nBit6: ID: PLL input divider control pin;\nBit7: OD: PLL output divider control pin." },
	{ V938_REGTYPE, "V9_REG_PAGE0_CLKCTRL2", V9_REG_PAGE0_CLKCTRL2, 0, 0,"Control PLL and clock input. Only reset by HW reset.\nBit7- Bit 6: Reserved\nBit5- Bit 0: F[5:0]PLL feedback 6-bit divider control pins" },
	{ V938_REGTYPE, "V9_REG_PAGE0_CLKCTRL3", V9_REG_PAGE0_CLKCTRL3, 0, 0,"Divider1 controller.\nBit7- Bit 0:8¡¯HFF: divider bypass, MCLK = PLL_CLK\n8¡¯H00~8¡¯HEE,MCLK = PLL_CLK/M\nM=CLKCTRL3[7:4]+CLKCTRL3[3:0]+2" },
	{ V938_REGTYPE, "V9_REG_PAGE0_CLKCTRL4", V9_REG_PAGE0_CLKCTRL4, 0, 0 },
	{ V938_REGTYPE, "V9_REG_PAGE0_DATA_DLY_SEL", V9_REG_PAGE0_DATA_DLY_SEL, 0, 0,"Data output delay cell select" },
	{ V938_REGTYPE, "V9_REG_PAGE0_A0_DLY_SEL", V9_REG_PAGE0_A0_DLY_SEL, 0, 0,"A0 output delay cell select" },
	{ V938_REGTYPE, "V9_REG_PAGE0_DATA_OEN_DLY_SEL", V9_REG_PAGE0_DATA_OEN_DLY_SEL, 0, 0,"Data output enable delay cell select" },
	{ V938_REGTYPE, "V9_REG_PAGE0_REF_DLY_SEL", V9_REG_PAGE0_REF_DLY_SEL, 0, 0,"Mclk_ref delay cell select" },
	{ V938_REGTYPE, "V9_REG_PAGE0_PHASE_DLY_SEL", V9_REG_PAGE0_PHASE_DLY_SEL, 0, 0,"Mclk_2x delay cell select" },
    { V938_REGTYPE, "V9_REG_PAGE0_PHASE_DLY_SEL", V9_REG_PAGE0_REF_PHASE_SEL, 0, 0,"Mclk_ref phase select" },
	{ V938_REGTYPE, "V9_REG_PAGE0_IE_DLY_SEL", V9_REG_PAGE0_IE_DLY_SEL, 0, 0,"Data input delay cell select" }
};

static const TRegUnit globalCtrReg[] =
{
	{ V938_REGTYPE, "V9_REG_PAGE1_CHIP_L", V9_REG_PAGE1_CHIP_L, 0, 0,"Release chip low byte" },
	{ V938_REGTYPE, "V9_REG_PAGE1_CHIP_H", V9_REG_PAGE1_CHIP_H, 0, 0,"Release chip high byte" },
	{ V938_REGTYPE, "V9_REG_PAGE1_GLBCTRL", V9_REG_PAGE1_GLBCTRL, 0, 0,"Global Control register\nBit7:  Start Sequencer\nBit6:  Start TMR Timer(Timer1).\nBit5:  When written:\n0: resume1: pause,\nWhen read:\n0: W.S. is not paused.1: W.S. is paused already.\nBit4:  Output mono / stereo control:\n1: mono output, 0: stereo output\nBit3: Sample Rate Conversion: \n 1: disabled,0: enabled;\nBit2: FM disabled for all channels:\n1: disabled0: enabled;\nBit1:  AM disabled for all channels.1: disabled0: enabled;\nBit0:  Start STMR timer(Timer0)." },
	{ V938_REGTYPE, "V9_REG_PAGE1_STOPALL", V9_REG_PAGE1_STOPALL, 0, 0,"Stop all channel, active high, read to clear,\nThis bit is set by sequencer" },
	{ V938_REGTYPE, "V9_REG_PAGE1_WS_MISC", V9_REG_PAGE1_WS_MISC, 0, 0,"Bit 7- Bit 1 : reserved,\nBit0: sync_out_en \n1 : enable wave engine sample data sync \noutput to DAC," },
	{ V938_REGTYPE, "V9_REG_PAGE1_GLBCFG", V9_REG_PAGE1_GLBCFG, 0, 0,"Bit7- Bit 5: Reserved;\nBit4: VOL_UPDT_TST,\n1¡¯b0: Normal mode,	1¡¯b1: Update enable\nBit3- Bit 2: reserved,Bit1: VOL_UPDT_INST,\n1¡¯b0: Volume update is active by the synchronous signal from DAC,\n1¡¯b1: Volume update instantly after write;\n Bit0: WS_CNT_SEL:	1¡¯b0: Fs*512,	1¡¯b1: Fs*768" },
	{ V938_REGTYPE, "V9_REG_PAGE1_SEL_CONV", V9_REG_PAGE1_SEL_CONV, 0, 0,"Converter select.\n1¡¯b0: don¡¯t use converter,\n1¡¯b1: use converter" },
	{ V938_REGTYPE, "V9_REG_PAGE1_BUF1_W_MARK", V9_REG_PAGE1_BUF1_W_MARK, 0, 0,"Bufer1 water mark\n2¡¯b00: 1/2 empty\n2¡¯b01: 3/4 empty\n2¡¯b10: 1/4 empty" },
	{ V938_REGTYPE, "V9_REG_PAGE1_BUF2_ADDR_L", V9_REG_PAGE1_BUF2_ADDR_L, 0, 0,"SEQ buffer2 start address low byte" },
	{ V938_REGTYPE, "V9_REG_PAGE1_BUF2_ADDR_H", V9_REG_PAGE1_BUF2_ADDR_H, 0, 0,"SEQ buffer2 start address high byte" },
	{ V938_REGTYPE, "V9_REG_PAGE1_BUF1_ADDR_L", V9_REG_PAGE1_BUF1_ADDR_L, 0, 0,"Buffer1 start address low byte" },
	{ V938_REGTYPE, "V9_REG_PAGE1_BUF1_ADDR_H", V9_REG_PAGE1_BUF1_ADDR_H, 0, 0,"Buffer1 start address high byte" },
	{ V938_REGTYPE, "V9_REG_PAGE1_E_EVENT_TYPE", V9_REG_PAGE1_E_EVENT_TYPE, 0, 0,"The EFIFO event error type when EFIFO_ERR interrupt comes" },
	{ V938_REGTYPE, "V9_REG_PAGE1_C_EVENT_TYPE", V9_REG_PAGE1_C_EVENT_TYPE, 0, 0,"The CFIFO event error type when CFIFO_ERR interrupt comes" },
	{ V938_REGTYPE, "V9_REG_PAGE1_TMR_L", V9_REG_PAGE1_TMR_L, 0, 0,"Low byte of current TMR[23:0] timer(Timer1) counter value" },
	{ V938_REGTYPE, "V9_REG_PAGE1_TMR_M", V9_REG_PAGE1_TMR_M, 0, 0,"Middle byte of current TMR[23:0] timer(Timer1) counter value" },
	{ V938_REGTYPE, "V9_REG_PAGE1_TMR_H", V9_REG_PAGE1_TMR_H, 0, 0,"High byte of current TMR[23:0] timer(Timer1) counter value" },
	{ V938_REGTYPE, "V9_REG_PAGE1_TMRTGT_L", V9_REG_PAGE1_TMRTGT_L, 0, 0,"The low byte of counter target of TMR timer(Timer1).\nThe count unit of this timer is based on TMRBASE.\nTime = TMR*(MCLK*TMRBASE)\nIf MCLK*TMRBASE = 1ms then" },
	{ V938_REGTYPE, "V9_REG_PAGE1_TMRTGT_M", V9_REG_PAGE1_TMRTGT_M, 0, 0,"The middle byte of counter target of TMR timer(Time1)." },
	{ V938_REGTYPE, "V9_REG_PAGE1_TMRTGT_H", V9_REG_PAGE1_TMRTGT_H, 0, 0,"The high byte of counter target of TMR timer(Time1)" },
	{ V938_REGTYPE, "V9_REG_PAGE1_STMR", V9_REG_PAGE1_STMR, 0, 0,"Current STMR timer(Timer0) counter value" },
	{ V938_REGTYPE, "V9_REG_PAGE1_STMRTGT", V9_REG_PAGE1_STMRTGT, 0, 0,"The counter target of STMR timer(Timer0),\nThe count unit of this timer is based on TMRBASE.\nTime = TMR*(MCLK*TMRBASE)\nIf MCLK*TMRBASE = 1ms then" },
	{ V938_REGTYPE, "V9_REG_PAGE1_TMRBASE_L", V9_REG_PAGE1_TMRBASE_L, 0, 0,"TMRBASE [15:0] low byte:\nDelta timer base time register. Count for 1ms, \nthe TMRBASE should set as follow:TMRBASE = 1ms/(MCLK period)" },
	{ V938_REGTYPE, "V9_REG_PAGE1_TMRBASE_H", V9_REG_PAGE1_TMRBASE_H, 0, 0,"TMRBASE [15:0] high byte" },
	{ V938_REGTYPE, "V9_REG_PAGE1_FRATIO_DLT0", V9_REG_PAGE1_FRATIO_DLT0, 0, 0 },
	{ V938_REGTYPE, "V9_REG_PAGE1_FRATIO_DLT1", V9_REG_PAGE1_FRATIO_DLT1, 0, 0 },
	{ V938_REGTYPE, "V9_REG_PAGE1_FRATIO_DLT2", V9_REG_PAGE1_FRATIO_DLT2, 0, 0 },
	{ V938_REGTYPE, "V9_REG_PAGE1_FRATIO_DLT3", V9_REG_PAGE1_FRATIO_DLT3, 0, 0 },
	{ V938_REGTYPE, "V9_REG_PAGE1_ANAERRFLAG", V9_REG_PAGE1_ANAERRFLAG, 0, 0,"Internal error state interrupt flag,\n write one to clear, write zero has no effect,\nneed to be cleared to get next interrupt of corresponding bit:\nBit7-2:  Reserved\nBit 1: PA short current interrupt\nBit 0:  OVER_TPA ,over temperature interrupt" },
	{ V938_REGTYPE, "V9_REG_PAGE1_ANAERRMASK", V9_REG_PAGE1_ANAERRMASK, 0, 0,"Bit effective to mask the ANAERRORFLAG interrupt generation of \ncorresponding bit, active high.\nBit7-2:  Reserved\nBit 1:  SHORT_I_EN\nBit 0:  OVER_T_EN" },
	{ V938_REGTYPE, "V9_REG_PAGE1_ERRORFLAG", V9_REG_PAGE1_ERRORFLAG, 0, 0,"Internal error state interrupt flag.\nBit7:  Reserved\nBit 6:  CFIFO_ERR\nBit 5:  EFIFO_ERR\nBit 4:  EFIFO_EPT\nBit 3:  SBUF_RDERR\nBit 2:  SBUF_WRERR\nBit 1:  FRAME_OVF\nBit 0:  CHN_REPEAT" },
	{ V938_REGTYPE, "V9_REG_PAGE1_ERRORMASK", V9_REG_PAGE1_ERRORMASK, 0, 0,"Bit effective to mask the error state interrupt \ngeneration of corresponding bit, active high" },
	{ V938_REGTYPE, "V9_REG_PAGE1_BUFFLAG0", V9_REG_PAGE1_BUFFLAG0, 0, 0,"Bit7: Reserved\nBit6: E_Half_Empty\nBit5: EFIFO FULL\nBit4: EFIFO EMPTY\nBit3: CFIFO FULL\nBit2 CFIFO EMPTY \nBit1: DLYFIFO FULL\nBit0: DLYFIFO EMPTY" },
	{ V938_REGTYPE, "V9_REG_PAGE1_BUFFLAG1", V9_REG_PAGE1_BUFFLAG1, 0, 0,"SFIFO flag, used in reverb case \nBit7- Bit 2 Reserved\nBit1: SFIFO FULL when reverb\nBit0: SFIFO EMPTY when reverb" },
	{ V938_REGTYPE, "V9_REG_PAGE1_DLYTIME", V9_REG_PAGE1_DLYTIME, 0, 0,"Delay time" },
	{ V938_REGTYPE, "V9_REG_PAGE1_CHNCTRL", V9_REG_PAGE1_CHNCTRL, 0, 0,"Bit7- Bit 2 Reserved\nBit1: STREAMEN\nBit0: SBACKEN  Reverb/Chorus enable/disable" },
	{ V938_REGTYPE, "V9_REG_PAGE1_BUF2_CMD_ADDR_L", V9_REG_PAGE1_BUF2_CMD_ADDR_L, 0, 0,"command buffer2 start address low byte" },
	{ V938_REGTYPE, "V9_REG_PAGE1_BUF2_CMD_ADDR_H", V9_REG_PAGE1_BUF2_CMD_ADDR_H, 0, 0,"command buffer2 start address high byte" },
	{ V938_REGTYPE, "V9_REG_PAGE1_V8051_ADDR_HH", V9_REG_PAGE1_V8051_ADDR_HH, 0, 0,"8051code start address high high byte" },
	{ V938_REGTYPE, "V9_REG_PAGE1_V8051_ADDR_L", V9_REG_PAGE1_V8051_ADDR_L, 0, 0,"8051code start address low byte" },
	{ V938_REGTYPE, "V9_REG_PAGE1_V8051_ADDR_H", V9_REG_PAGE1_V8051_ADDR_H, 0, 0,"8051code start address high byte" },
	{ V938_REGTYPE, "V9_REG_PAGE1_CMDSTATUS", V9_REG_PAGE1_CMDSTATUS, 0, 0,"Command buffer status. Read to clear.\nBit 0: Command Finished;\nBit 1: Command failed.\nBit7- Bit 2 Reserved" },
	{ V938_REGTYPE, "V9_REG_PAGE1_CMDATA0", V9_REG_PAGE1_CMDATA0, 0, 0,"Channel register read back data, byte 0" },
	{ V938_REGTYPE, "V9_REG_PAGE1_CMDATA1", V9_REG_PAGE1_CMDATA1, 0, 0,"Channel register read back data, byte 1" },
	{ V938_REGTYPE, "V9_REG_PAGE1_CMDATA2", V9_REG_PAGE1_CMDATA2, 0, 0,"Channel register read back data, byte 2" },
	{ V938_REGTYPE, "V9_REG_PAGE1_CMDATA3", V9_REG_PAGE1_CMDATA3, 0, 0,"Channel register read back data, byte 3" },
	{ V938_REGTYPE, "V9_REG_PAGE1_STARTLOAD", V9_REG_PAGE1_STARTLOAD, 0, 0,"Start load from FLASH to external SRAM\nBit 0: 1: start load; 0: not s tart load" },
	{ V938_REGTYPE, "V9_REG_PAGE1_LOADDONE", V9_REG_PAGE1_LOADDONE, 0, 0,"Load from FLASH to SRAM finished." },
	{ V938_REGTYPE, "V9_REG_PAGE1_EFIFO_RMN_L", V9_REG_PAGE1_EFIFO_RMN_L, 0, 0 },
	{ V938_REGTYPE, "V9_REG_PAGE1_EFIFO_RMN_H", V9_REG_PAGE1_EFIFO_RMN_H, 0, 0 },
	{ V938_REGTYPE, "V9_REG_PAGE1_EFIFO_EPT_TT", V9_REG_PAGE1_EFIFO_EPT_TT, 0, 0 },
	{ V938_REGTYPE, "V9_REG_PAGE1_VOL_GAIN_L", V9_REG_PAGE1_VOL_GAIN_L, 0, 0,"Global gain value left channel" },
	{ V938_REGTYPE, "V9_REG_PAGE1_VOL_GAIN_R", V9_REG_PAGE1_VOL_GAIN_R, 0, 0,"Global gain value right channel" },
	{ V938_REGTYPE, "V9_REG_PAGE1_SWRST1", V9_REG_PAGE1_SWRST1, 0, 0,"SW reset for each block. Auto clear by HW.\nBit 7: Global SW reset\nBit 6: EFIFO clear\n##Bit 5: SFIFO clear; reserved\nBit 4: WS reset\nBit 3: Sequencer reset\nBit 2: eq reset\nBit 1: TMR timer(Timer1) reset.\nBit 0: STMR timer(Time0) reset" },
	{ V938_REGTYPE, "V9_REG_PAGE1_SWRST2", V9_REG_PAGE1_SWRST2, 0, 0,"SW reset for each block. Auto clear by HW.\nBit 7: LED reset\nBit 6: I2S sw reset\nBit 5: System reset\nBit 4: int reset\nBit 3: BIU MCLK domain reset\nBit 2: Command FIFO reset\nBit 1: Vibrator reset\nBit 0: MP3 reset" },
	{ V938_REGTYPE, "V9_REG_PAGE1_SWRST3", V9_REG_PAGE1_SWRST3, 0, 0,"Bit0: SFIFO0 clear;\nBit1: SFIFO1 clear;\nBit2: SFIFO2 clear;\nBit3: SFIFO3 clear;\nOthers: reserved" },
	{ V938_REGTYPE, "V9_REG_PAGE1_VERSION_L", V9_REG_PAGE1_VERSION_L, 0, 0,"Release version low byte" },
	{ V938_REGTYPE, "V9_REG_PAGE1_VERSION_H", V9_REG_PAGE1_VERSION_H, 0, 0,"Release version high byte" },
	{ V938_REGTYPE, "V9_REG_PAGE1_INTCTRL", V9_REG_PAGE1_INTCTRL, 0, 0,"Interrupt configuration control register\nBit0:1¡¯b0: edge trigger; 1¡¯b1: level trigger.\nBit1:it¡¯s active when int_trig_sel = 1,1¡¯b0: high level; 1¡¯b1: low level\nBit2:it¡¯s active when int_trig_sel = 0,1¡¯b0:rise edge; 1¡¯b1: fall edge\nBit3: reserved\nBit7-bit4: int_wid_target	it¡¯s active when int_trig_sel = 0	\n4¡¯h0: 1 MCLK width\n	4¡¯h1: 2 MCLK width	\n¡­	\n4¡¯hf: 16 MCLK width" },
	{ V938_REGTYPE, "V9_REG_PAGE1_INTEN0", V9_REG_PAGE1_INTEN0, 0, 0,"Global interrupt enable / disable.0: disable, 1: enable.\nBit 0: IE_STMR: enable STMR(Timer0) interrupt\nBit 1: IE_EVENT, enable event FIFO empty interrupt\nBit 2: IE_TMR, enable TMR(Timer1) interrupt enable\nBit 3: IE_ERR_FLAG\nBit4: IE_SBUF0_EMPTY\nBit5: IE_SBUF1_EMPTY\nBit6: IE_SBUF2_EMPTY\nBit7: IE_SBUF3_EMPTY" },
	{ V938_REGTYPE, "V9_REG_PAGE1_INTFLAG0", V9_REG_PAGE1_INTFLAG0, 0, 0,"Global interrupt flag. Read to clear.\nBit7:SBUF3_EMPTY interrupt\nBit6: SBUF2_EMPTY interrupt\nBit5: SBUF1_EMPTY interrupt\nBit4: SBUF0_EMPTY interrupt \nBit3: ERRFLAG Intterupt\nBit2: TMR interrupt (Timer1)\nBit1: Event FIFO empty interrupt 	(status type)\nBit0: STMR interrupt(Timer0)" },
	{ V938_REGTYPE, "V9_REG_PAGE1_INTEN1", V9_REG_PAGE1_INTEN1, 0, 0,"Global interrupt enable / disable.0: disable, 1: enable \nBit0: IE_MP3_BUF_EMP\nBit7-bit1: IE_SW_INT" },
	{ V938_REGTYPE, "V9_REG_PAGE1_INTFLAG1", V9_REG_PAGE1_INTFLAG1, 0, 0,"Global interrupt flag. Read to clear\nBit0: MP3_INBUF_EMP\nBit7-bit1: SW_INT" },
	{ V938_REGTYPE, "V9_REG_PAGE1_INTLOCK", V9_REG_PAGE1_INTLOCK, 0, 0,"Interrupt is lock now. When INTLOCK = 1¡¯b1, \nINTFLAG can¡¯t be changed by hw." },
	{ V938_REGTYPE, "V9_REG_PAGE1_INTSERV", V9_REG_PAGE1_INTSERV, 0, 0,"When corresponding bit is set, host can start to \nprocessing the corresponding interrupt in showed in \nINTFLAG register, the HW internal status is in-active that is \nto say no new interrupt can be create.\nBit0: Res.\nBit1: Event FIFO int serve\nBit2: mp3_all_empty int serve\nBit3: mp3 int serve\nBit7- Bit 4: sfifi int serve" },
	{ V938_REGTYPE, "V9_REG_PAGE1_INTEN2", V9_REG_PAGE1_INTEN2, 0, 0,"Global interrupt enable / disable.0: disable, 1: enable \nBit3-bit0: IE_AUTOSTOPEN\nBit4: IE_MP3_ALL_EMPTY" },
	{ V938_REGTYPE, "V9_REG_PAGE1_INTFLAG2", V9_REG_PAGE1_INTFLAG2, 0, 0,"Global interrupt flag. Read to clear\nbit4:  mp3_all_empty int\nBit3:bit0: AUTOSTOPEN" },
	{ V938_REGTYPE, "V9_REG_PAGE1_INT_DLY_CNT0", V9_REG_PAGE1_INT_DLY_CNT0, 0, 0,"Interrupt delay counter low bytes" },
	{ V938_REGTYPE, "V9_REG_PAGE1_INT_DLY_CNT1", V9_REG_PAGE1_INT_DLY_CNT1, 0, 0,"Interrupt delay counter hith bytes" },
	{ V938_REGTYPE, "V9_REG_PAGE1_DLY_SEL", V9_REG_PAGE1_DLY_SEL, 0, 0,"Interrupt select;\n1¡¯b0: is delay mode\n1¡¯b1: is no delay mode" },
	{ V938_REGTYPE, "V9_REG_PAGE1_SW_INT", V9_REG_PAGE1_SW_INT, 0, 0,"Soft ware interrupt" },
	{ V938_REGTYPE, "V9_REG_PAGE1_AUTOSTOPEN", V9_REG_PAGE1_AUTOSTOPEN, 0, 0,"Channel automatic stop enable\nBit3-bit0: \n1¡¯b1: stop enable\n1¡¯b0: disable" },
	{ V938_REGTYPE, "V9_REG_PAGE1_REPEAT_INT_CNT0", V9_REG_PAGE1_REPEAT_INT_CNT0, 0, 0,"Repeat counter target[7:0]" },
	{ V938_REGTYPE, "V9_REG_PAGE1_REPEAT_INT_CNT1", V9_REG_PAGE1_REPEAT_INT_CNT1, 0, 0,"Repeat counter target[15:8]" },
	{ V938_REGTYPE, "V9_REG_PAGE1_GLB_MOD_SEL", V9_REG_PAGE1_GLB_MOD_SEL, 0, 0,"Global mode conctrl register\n[0]: intflag clear select:\n 0 is write2clear\n 1 is read2clear\n[1]: interrupt repeat enable\n  0: is enable\n  1: is disable\n[2]: cmdstatus clear select:\n  0: is write2clear\n  1: is read2clear\n[3] stop_all clear select:\n  0: is write2clear\n  1: is read2clear" },
	{ V938_REGTYPE, "V9_REG_PAGE1_STREAM_CLR_BYPASS", V9_REG_PAGE1_STREAM_CLR_BYPASS, 0, 0,"Stream clear pointer bypass\n[0]:\n  1¡¯b0: is not bypass\n  1¡¯b1: is bypass\n[7:1]: reserved" }
};

static const TRegUnit fifoWrReg[] =
{
	{ V938_REGTYPE, "V9_REG_PAGE1_EFIFO", V9_REG_PAGE1_EFIFO, 0, 0,"Event FIFO writing data" },
	{ V938_REGTYPE, "V9_REG_PAGE1_SFIFO", V9_REG_PAGE1_SFIFO, 0, 0,"Stream FIFO writing data" },
	{ V938_REGTYPE, "V9_REG_PAGE1_CFIFO", V9_REG_PAGE1_CFIFO, 0, 0,"Instantaneous command FIFO writing data" },
	{ V938_REGTYPE, "V9_REG_PAGE1_SBUF0_FULL", V9_REG_PAGE1_SBUF0_FULL, 0, 0, "Bit-0 Stream channel 0 buffer0 full.\nBit-1 Stream channel 2 buffer0 full.\nBit-2 Stream channel 1 buffer0 full.\nBit-3 Stream channel 3 buffer0 full."},
	{ V938_REGTYPE, "V9_REG_PAGE1_SBUF1_FULL", V9_REG_PAGE1_SBUF1_FULL, 0, 0, "Bit-0 Stream channel 0 buffer1 full.\nBit-1 Stream channel 1 buffer1 full.\nBit-2 Stream channel 2 buffer1 full.\nBit-3 Stream channel 3 buffer1 full."}
};

static const TRegUnit chanCtrReg[] =
{
	{ V938_REGTYPE, "V9_REG_PAGE1_CHNSTART0", V9_REG_PAGE1_CHNSTART0, 0, 0, "Start of each channel.\n1¡¯b1: the channel is working.\n1¡¯b0: the channel is stopped.\nThe bit will be changed from 0 to 1 when 1 is written into it.\nThe bit will be changed from 1 to 0 in the following cases:\n1)the corresponding bit in CHNSTOP is written with a 1;\n2)PCM/ADPCM channel runs out of data.\n3)MIDI channel¡¯s envelope drops down to ¨C63.984375dB.\n4)current envelope segment is delay-stop mode and is finished."},
	{ V938_REGTYPE, "V9_REG_PAGE1_CHNSTART1", V9_REG_PAGE1_CHNSTART1, 0, 0 },
	{ V938_REGTYPE, "V9_REG_PAGE1_CHNSTART2", V9_REG_PAGE1_CHNSTART2, 0, 0 },
	{ V938_REGTYPE, "V9_REG_PAGE1_CHNSTART3", V9_REG_PAGE1_CHNSTART3, 0, 0 },
	{ V938_REGTYPE, "V9_REG_PAGE1_CHNSTART4", V9_REG_PAGE1_CHNSTART4, 0, 0 },
	{ V938_REGTYPE, "V9_REG_PAGE1_CHNSTART5", V9_REG_PAGE1_CHNSTART5, 0, 0 },
	{ V938_REGTYPE, "V9_REG_PAGE1_CHNSTART6", V9_REG_PAGE1_CHNSTART6, 0, 0 },
	{ V938_REGTYPE, "V9_REG_PAGE1_CHNSTART7", V9_REG_PAGE1_CHNSTART7, 0, 0 },
	{ V938_REGTYPE, "V9_REG_PAGE1_CHNSTOP0", V9_REG_PAGE1_CHNSTOP0, 0, 0, "Stop of each channel.\nWhen written: write 1 means the corresponding channel is stopped;\n write 0 has no effect.\nWhen read: returns the value of CHNSTART."},
	{ V938_REGTYPE, "V9_REG_PAGE1_CHNSTOP1", V9_REG_PAGE1_CHNSTOP1, 0, 0 },
	{ V938_REGTYPE, "V9_REG_PAGE1_CHNSTOP2", V9_REG_PAGE1_CHNSTOP2, 0, 0 },
	{ V938_REGTYPE, "V9_REG_PAGE1_CHNSTOP3", V9_REG_PAGE1_CHNSTOP3, 0, 0 },
	{ V938_REGTYPE, "V9_REG_PAGE1_CHNSTOP4", V9_REG_PAGE1_CHNSTOP4, 0, 0 },
	{ V938_REGTYPE, "V9_REG_PAGE1_CHNSTOP5", V9_REG_PAGE1_CHNSTOP5, 0, 0 },
	{ V938_REGTYPE, "V9_REG_PAGE1_CHNSTOP6", V9_REG_PAGE1_CHNSTOP6, 0, 0 },
	{ V938_REGTYPE, "V9_REG_PAGE1_CHNSTOP7", V9_REG_PAGE1_CHNSTOP7, 0, 0 },
	{ V938_REGTYPE, "V9_REG_PAGE1_CHNDLY0", V9_REG_PAGE1_CHNDLY0, 0, 0, "Delay status of each channel.\n 0: Normal1: The corresponding channel is in delay mode."},
	{ V938_REGTYPE, "V9_REG_PAGE1_CHNDLY1", V9_REG_PAGE1_CHNDLY1, 0, 0 },
	{ V938_REGTYPE, "V9_REG_PAGE1_CHNDLY2", V9_REG_PAGE1_CHNDLY2, 0, 0 },
	{ V938_REGTYPE, "V9_REG_PAGE1_CHNDLY3", V9_REG_PAGE1_CHNDLY3, 0, 0 },
	{ V938_REGTYPE, "V9_REG_PAGE1_CHNDLY4", V9_REG_PAGE1_CHNDLY4, 0, 0 },
	{ V938_REGTYPE, "V9_REG_PAGE1_CHNDLY5", V9_REG_PAGE1_CHNDLY5, 0, 0 },
	{ V938_REGTYPE, "V9_REG_PAGE1_CHNDLY6", V9_REG_PAGE1_CHNDLY6, 0, 0 },
	{ V938_REGTYPE, "V9_REG_PAGE1_CHNDLY7", V9_REG_PAGE1_CHNDLY7, 0, 0 },
	{ V938_REGTYPE, "V9_REG_PAGE1_DLYEND0", V9_REG_PAGE1_DLYEND0, 0, 0, "Delay end of each channel.\nIt only can be write when corresponding bit of CHNSTART \nis high and reset by hardware(wave engine).\nWrite 0: No effect.\nWrite 1: Corresponding channel ends delay mode and comes into next segment."},
	{ V938_REGTYPE, "V9_REG_PAGE1_DLYEND1", V9_REG_PAGE1_DLYEND1, 0, 0 },
	{ V938_REGTYPE, "V9_REG_PAGE1_DLYEND2", V9_REG_PAGE1_DLYEND2, 0, 0 },
	{ V938_REGTYPE, "V9_REG_PAGE1_DLYEND3", V9_REG_PAGE1_DLYEND3, 0, 0 },
	{ V938_REGTYPE, "V9_REG_PAGE1_DLYEND4", V9_REG_PAGE1_DLYEND4, 0, 0 },
	{ V938_REGTYPE, "V9_REG_PAGE1_DLYEND5", V9_REG_PAGE1_DLYEND5, 0, 0 },
	{ V938_REGTYPE, "V9_REG_PAGE1_DLYEND6", V9_REG_PAGE1_DLYEND6, 0, 0 },
	{ V938_REGTYPE, "V9_REG_PAGE1_DLYEND7", V9_REG_PAGE1_DLYEND7, 0, 0 },
	{ V938_REGTYPE, "V9_REG_PAGE1_OP_MODE", V9_REG_PAGE1_OP_MODE, 0, 0, "8¡¯h00: HOST_WAVE + MIDI\n8¡¯h20: HOST_WAVE + SD_MIDI\n8¡¯h30: SD_WAVE + SD_MIDI\n8¡¯h40: HOST_MP3 + MIDI\n8¡¯h60: HOST_MP3 + SD_MIDI\n8¡¯h70: SD_MP3 + SD_MIDI\n8¡¯hF0: SD player"}
};

static const TRegUnit audioCtrReg[] = 
{
	{ V938_REGTYPE, "V9_REG_PAGE1_ADCTRL", V9_REG_PAGE1_ADCTRL, 0, 0, "ADPCM control register\nBit 1- Bit 0: Law control\n   0: linear; 1: a-law; 2: u-law; 3: res.\nBit 3- Bit 2: ADPCM compression rate control\n  0: 4 bit; 1: 3 bit; 2: 2 bit; 3: res\nBit 7- Bit4: Reserved"},
	{ V938_REGTYPE, "V9_REG_PAGE1_VOLMID_L", V9_REG_PAGE1_VOLMID_L, 0, 0, "Master left volume of MIDI sound, used for all \nMIDI channels.(6.2)\n00H: 0DB\nff H: -63.75DB"},
	{ V938_REGTYPE, "V9_REG_PAGE1_VOLMID_R", V9_REG_PAGE1_VOLMID_R, 0, 0, "Master right volume of MIDI sound, used for all \nMIDI channels. (6.2)\n00H: 0DB\nff H: -63.75DB"},
	{ V938_REGTYPE, "V9_REG_PAGE1_VOLWAV_L", V9_REG_PAGE1_VOLWAV_L, 0, 0, "Master left volume of PCM/ADPCM sound, used for all \nPCM/ADPCM channels. (6.2)\n00H: 0DB\nff H: -63.75DB"},
	{ V938_REGTYPE, "V9_REG_PAGE1_VOLWAV_R", V9_REG_PAGE1_VOLWAV_R, 0, 0, "Master right volume of PCM/ADPCM sound, used for all \nPCM/ADPCM channels. (6.2)\n00H: 0DB\nff H: -63.75DB"},
	{ V938_REGTYPE, "V9_REG_PAGE1_HPNVOL_L", V9_REG_PAGE1_HPNVOL_L, 0, 0, "Bit3- Bit 0: DAC left channel PGAT output gain \nprogramming values which is used to control head \nphone left channel volume.\n  0000: 0dB\n  0001: -2dB\n  ...\n  1111: -30dB\nBit7- Bit 4: Reserved"},
	{ V938_REGTYPE, "V9_REG_PAGE1_HPNVOL_R", V9_REG_PAGE1_HPNVOL_R, 0, 0, "Bit3- Bit 0: DAC right channel PGAT output gain \nprogramming values which is used to control head \nphone right channel volume.\n  0000: 0dB\n  0001: -2dB\n  ...\n  1111: -30dB\nBit7- Bit 4: Reserved"},
	{ V938_REGTYPE, "V9_REG_PAGE1_DACPGG", V9_REG_PAGE1_DACPGG, 0, 0, "Bit3- Bit 0: MIXER output gain programming values\n  0000: 0dB\n  0001: -2dB\n  ...\n  1111: -30dB\nBit7- Bit 4: Reserved"},
	{ V938_REGTYPE, "V9_REG_PAGE1_MUTECTRL", V9_REG_PAGE1_MUTECTRL, 0, 0 },
	{ V938_REGTYPE, "V9_REG_PAGE1_E_W_MARK", V9_REG_PAGE1_E_W_MARK, 0, 0, "Event fifo water mark"},
	{ V938_REGTYPE, "V9_REG_PAGE1_DT_RETRI", V9_REG_PAGE1_DT_RETRI, 0, 0 },
	{ V938_REGTYPE, "V9_REG_PAGE1_REG000", V9_REG_PAGE1_REG000, 0, 0, "Bank0,offset0, number0 global register of audio\n(fmctrl,evlpmod2,evlpmod1,evlpmod0)"},
	{ V938_REGTYPE, "V9_REG_PAGE1_REG010", V9_REG_PAGE1_REG010, 0, 0, "chnvolen,lfosign1,sindir1,chnatrb,bitctrl,signctrl"},
	{ V938_REGTYPE, "V9_REG_PAGE1_INTPCOEF0", V9_REG_PAGE1_INTPCOEF0, 0, 0, "Global register of audio[7:0], intpcoef"},
	{ V938_REGTYPE, "V9_REG_PAGE1_INTPCOEF1", V9_REG_PAGE1_INTPCOEF1, 0, 0, "Global register of audio[11:8], intpcoef"},
	{ V938_REGTYPE, "V9_REG_PAGE1_REG020", V9_REG_PAGE1_REG020, 0, 0, "Bank0,offset2, number0 global register of audiosinval"},
	{ V938_REGTYPE, "V9_REG_PAGE1_ECNTINIT2", V9_REG_PAGE1_ECNTINIT2, 0, 0, "Global register of audio, ecntinit2"},
	{ V938_REGTYPE, "V9_REG_PAGE1_PREVAL0", V9_REG_PAGE1_PREVAL0, 0, 0, "global register of audio[7:0], preval0"},
	{ V938_REGTYPE, "V9_REG_PAGE1_PREVAL1", V9_REG_PAGE1_PREVAL1, 0, 0, "global register of audio[15:8], preval1"},
	{ V938_REGTYPE, "V9_REG_PAGE1_REG111", V9_REG_PAGE1_REG111, 0, 0, "vlpchg2[8],preindex"},
	{ V938_REGTYPE, "V9_REG_PAGE1_EVLPCHG20", V9_REG_PAGE1_EVLPCHG20, 0, 0, "global register of audio[7:0], evlpchg2"},
	{ V938_REGTYPE, "V9_REG_PAGE1_LOADADDR", V9_REG_PAGE1_LOADADDR, 0, 0, "Load sfifo address"},
	{ V938_REGTYPE, "V9_REG_PAGE1_SFIFO0_WM", V9_REG_PAGE1_SFIFO0_WM, 0, 0, "Sfifo0 water mark"},
	{ V938_REGTYPE, "V9_REG_PAGE1_SFIFO1_WM", V9_REG_PAGE1_SFIFO1_WM, 0, 0, "Sfifo1 water mark"},
	{ V938_REGTYPE, "V9_REG_PAGE1_SFIFO2_WM", V9_REG_PAGE1_SFIFO2_WM, 0, 0, "Sfifo2 water mark"},
	{ V938_REGTYPE, "V9_REG_PAGE1_SFIFO3_WM", V9_REG_PAGE1_SFIFO3_WM, 0, 0, "Sfifo3 water mark"},
	{ V938_REGTYPE, "V9_REG_PAGE1_SFIFO0_AW_BL", V9_REG_PAGE1_SFIFO0_AW_BL, 0, 0, "SFIFO0 write address base address low"},
	{ V938_REGTYPE, "V9_REG_PAGE1_SFIFO0_AW_BH", V9_REG_PAGE1_SFIFO0_AW_BH, 0, 0, "SFIFO0 write address base address high"},
	{ V938_REGTYPE, "V9_REG_PAGE1_SFIFO0_AW_EL", V9_REG_PAGE1_SFIFO0_AW_EL, 0, 0, "SFIFO0 write address end address low"},
	{ V938_REGTYPE, "V9_REG_PAGE1_SFIFO0_AW_EH", V9_REG_PAGE1_SFIFO0_AW_EH, 0, 0, "SFIFO0 write address end address high"},
	{ V938_REGTYPE, "V9_REG_PAGE1_SFIFO1_AW_BL", V9_REG_PAGE1_SFIFO1_AW_BL, 0, 0, "SFIFO1 write address base address low"},
	{ V938_REGTYPE, "V9_REG_PAGE1_SFIFO1_AW_BH", V9_REG_PAGE1_SFIFO1_AW_BH, 0, 0, "SFIFO1 write address base address high"},
	{ V938_REGTYPE, "V9_REG_PAGE1_SFIFO1_AW_EL", V9_REG_PAGE1_SFIFO1_AW_EL, 0, 0, "SFIFO1 write address end address low"},
	{ V938_REGTYPE, "V9_REG_PAGE1_SFIFO1_AW_EH", V9_REG_PAGE1_SFIFO1_AW_EH, 0, 0, "SFIFO1 write address end address high"},
	{ V938_REGTYPE, "V9_REG_PAGE1_SFIFO2_AW_BL", V9_REG_PAGE1_SFIFO2_AW_BL, 0, 0, "SFIFO2 write address base address low"},
	{ V938_REGTYPE, "V9_REG_PAGE1_SFIFO2_AW_BH", V9_REG_PAGE1_SFIFO2_AW_BH, 0, 0,"SFIFO2 write address base address high" },
	{ V938_REGTYPE, "V9_REG_PAGE1_SFIFO2_AW_EL", V9_REG_PAGE1_SFIFO2_AW_EL, 0, 0, "SFIFO2 write address end address low"},
	{ V938_REGTYPE, "V9_REG_PAGE1_SFIFO2_AW_EH", V9_REG_PAGE1_SFIFO2_AW_EH, 0, 0, "SFIFO2 write address end address high"},
	{ V938_REGTYPE, "V9_REG_PAGE1_SFIFO3_AW_BL", V9_REG_PAGE1_SFIFO3_AW_BL, 0, 0, "SFIFO0 write address base address low"},
	{ V938_REGTYPE, "V9_REG_PAGE1_SFIFO3_AW_BH", V9_REG_PAGE1_SFIFO3_AW_BH, 0, 0, "SFIFO0 write address base address high"},
	{ V938_REGTYPE, "V9_REG_PAGE1_SFIFO3_AW_EL", V9_REG_PAGE1_SFIFO3_AW_EL, 0, 0, "SFIFO0 write address end address low"},
	{ V938_REGTYPE, "V9_REG_PAGE1_SFIFO3_AW_EH", V9_REG_PAGE1_SFIFO3_AW_EH, 0, 0, "SFIFO0 write address end address high"},
	{ V938_REGTYPE, "V9_REG_PAGE1_SFIFO0_AR_BL", V9_REG_PAGE1_SFIFO0_AR_BL, 0, 0, "SFIFO0 read base address low"},
	{ V938_REGTYPE, "V9_REG_PAGE1_SFIFO0_AR_BH", V9_REG_PAGE1_SFIFO0_AR_BH, 0, 0, "SFIFO0 read base address high"},
	{ V938_REGTYPE, "V9_REG_PAGE1_SFIFO0_AR_EL", V9_REG_PAGE1_SFIFO0_AR_EL, 0, 0, "SFIFO0 read end address low"},
	{ V938_REGTYPE, "V9_REG_PAGE1_SFIFO0_AR_EH", V9_REG_PAGE1_SFIFO0_AR_EH, 0, 0, "SFIFO0 read end address high"},
	{ V938_REGTYPE, "V9_REG_PAGE1_SFIFO1_AR_BL", V9_REG_PAGE1_SFIFO1_AR_BL, 0, 0, "SFIFO1 read base address low"},
	{ V938_REGTYPE, "V9_REG_PAGE1_SFIFO1_AR_BH", V9_REG_PAGE1_SFIFO1_AR_BH, 0, 0, "SFIFO1 read base address high"},
	{ V938_REGTYPE, "V9_REG_PAGE1_SFIFO1_AR_EL", V9_REG_PAGE1_SFIFO1_AR_EL, 0, 0, "SFIFO1 read end address low"},
	{ V938_REGTYPE, "V9_REG_PAGE1_SFIFO1_AR_EH", V9_REG_PAGE1_SFIFO1_AR_EH, 0, 0, "SFIFO1 read end address high"},
	{ V938_REGTYPE, "V9_REG_PAGE1_SFIFO2_AR_BL", V9_REG_PAGE1_SFIFO2_AR_BL, 0, 0, "SFIFO2 read base address low"},
	{ V938_REGTYPE, "V9_REG_PAGE1_SFIFO2_AR_BH", V9_REG_PAGE1_SFIFO2_AR_BH, 0, 0, "SFIFO2 read base address high"},
	{ V938_REGTYPE, "V9_REG_PAGE1_SFIFO2_AR_EL", V9_REG_PAGE1_SFIFO2_AR_EL, 0, 0, "SFIFO2 read end address low"},
	{ V938_REGTYPE, "V9_REG_PAGE1_SFIFO2_AR_EH", V9_REG_PAGE1_SFIFO2_AR_EH, 0, 0, "SFIFO2 read end address high"},
	{ V938_REGTYPE, "V9_REG_PAGE1_SFIFO3_AR_BL", V9_REG_PAGE1_SFIFO3_AR_BL, 0, 0, "SFIFO3 read base address low"},
	{ V938_REGTYPE, "V9_REG_PAGE1_SFIFO3_AR_BH", V9_REG_PAGE1_SFIFO3_AR_BH, 0, 0, "SFIFO3 read base address high"},
	{ V938_REGTYPE, "V9_REG_PAGE1_SFIFO3_AR_EL", V9_REG_PAGE1_SFIFO3_AR_EL, 0, 0, "SFIFO3 read end address low"},
	{ V938_REGTYPE, "V9_REG_PAGE1_SFIFO3_AR_EH", V9_REG_PAGE1_SFIFO3_AR_EH, 0, 0, "SFIFO3 read end address high"}
};

static const TRegUnit mp3Reg[] =
{
	{ V938_REGTYPE, "V9_REG_PAGE2_CLR_A", V9_REG_PAGE2_CLR_A, 0, 0, "Clear mp3 input buffer point"},
	{ V938_REGTYPE, "V9_REG_PAGE2_MP3_RD_PTR_L", V9_REG_PAGE2_MP3_RD_PTR_L, 0, 0, "MP3 input FIFO read pointer [7:0]"},
	{ V938_REGTYPE, "V9_REG_PAGE2_MP3_RD_PTR_H", V9_REG_PAGE2_MP3_RD_PTR_H, 0, 0, "MP3 input FIFO read pointer [11:8]"},
	{ V938_REGTYPE, "V9_REG_PAGE2_MP3_WR_PTR_L", V9_REG_PAGE2_MP3_WR_PTR_L, 0, 0, "MP3 input FIFO write pointer [7:0]"},
	{ V938_REGTYPE, "V9_REG_PAGE2_MP3_WR_PTR_H", V9_REG_PAGE2_MP3_WR_PTR_H, 0, 0, "MP3 input FIFO write pointer [11:8]"},
	{ V938_REGTYPE, "V9_REG_PAGE2_W_MARK", V9_REG_PAGE2_W_MARK, 0, 0, "Mp3 input buffer water mark\n0: 1/41: 1/22: 3/4"},
	{ V938_REGTYPE, "V9_REG_PAGE2_MP3_DONE", V9_REG_PAGE2_MP3_DONE, 0, 0, "Indicate the mp3 data have sent done"},
	{ V938_REGTYPE, "V9_REG_PAGE2_MP3_PARA0", V9_REG_PAGE2_MP3_PARA0, 0, 0, "Indicate the mp3 parameter\n(Original,VersionId,ErrProtect,CpyRight,BitRateIdx)"},
	{ V938_REGTYPE, "V9_REG_PAGE2_MP3_PARA1", V9_REG_PAGE2_MP3_PARA1, 0, 0, "Indicate the mp3 parameter\n{SampFrqIdx,AudioMode,ModExten,Emphasis}"},
	{ V938_REGTYPE, "V9_REG_PAGE2_MP3_PARA2", V9_REG_PAGE2_MP3_PARA2, 0, 0, "Indicate the mp3 parameter\n{7¡¯b0,FrmLocked}"},
	{ V938_REGTYPE, "V9_REG_PAGE2_MP3_EQBAND0", V9_REG_PAGE2_MP3_EQBAND0, 0, 0, "[5:0]: 60hz band"},
	{ V938_REGTYPE, "V9_REG_PAGE2_MP3_EQBAND1", V9_REG_PAGE2_MP3_EQBAND1, 0, 0, "[5:0]: 170hz band"},
	{ V938_REGTYPE, "V9_REG_PAGE2_MP3_EQBAND2", V9_REG_PAGE2_MP3_EQBAND2, 0, 0, "[5:0]: 310hz band"},
	{ V938_REGTYPE, "V9_REG_PAGE2_MP3_EQBAND3", V9_REG_PAGE2_MP3_EQBAND3, 0, 0, "[5:0]: 600hz band"},
	{ V938_REGTYPE, "V9_REG_PAGE2_MP3_EQBAND4", V9_REG_PAGE2_MP3_EQBAND4, 0, 0, "[5:0]: 1Khz band"},
	{ V938_REGTYPE, "V9_REG_PAGE2_MP3_EQBAND5", V9_REG_PAGE2_MP3_EQBAND5, 0, 0, "[5:0]: 3Khz band"},
	{ V938_REGTYPE, "V9_REG_PAGE2_MP3_EQBAND6", V9_REG_PAGE2_MP3_EQBAND6, 0, 0, "[5:0]: 6Khz band"},
	{ V938_REGTYPE, "V9_REG_PAGE2_MP3_EQBAND7", V9_REG_PAGE2_MP3_EQBAND7, 0, 0, "[5:0]: 12Khz band"},
	{ V938_REGTYPE, "V9_REG_PAGE2_MP3_EQBAND8", V9_REG_PAGE2_MP3_EQBAND8, 0, 0, "[5:0]: 14Khz band"},
	{ V938_REGTYPE, "V9_REG_PAGE2_MP3_EQBAND9", V9_REG_PAGE2_MP3_EQBAND9, 0, 0, "[5:0]: 16Khz band"},
	{ V938_REGTYPE, "V9_REG_PAGE2_MP3_VOLSTEP", V9_REG_PAGE2_MP3_VOLSTEP, 0, 0, "32 steps volume control signal. It represents 32 \nvolume control steps(0 ¨C31). 0 is the default value \nrepresenting no volume gain, 31 the maximum \nvalue for volume gain"},
	{ V938_REGTYPE, "V9_REG_PAGE2_MFIFO", V9_REG_PAGE2_MFIFO, 0, 0, "MP3 writing data"}
};

static const TRegUnit eqReg[] =
{
	{ V938_REGTYPE, "V9_REG_PAGE2_EQBAND0", V9_REG_PAGE2_EQBAND0, 0, 0, "[4:0]: 250hz band"},
	{ V938_REGTYPE, "V9_REG_PAGE2_EQBAND1", V9_REG_PAGE2_EQBAND1, 0, 0, "[9:5]: 500hz band"},
	{ V938_REGTYPE, "V9_REG_PAGE2_EQBAND2", V9_REG_PAGE2_EQBAND2, 0, 0, "[14:10]: 750hz band"},
	{ V938_REGTYPE, "V9_REG_PAGE2_EQBAND3", V9_REG_PAGE2_EQBAND3, 0, 0, "[19:15]: 1khz band"},
	{ V938_REGTYPE, "V9_REG_PAGE2_EQBAND4", V9_REG_PAGE2_EQBAND4, 0, 0, "[24:20]: 2khz band"},
	{ V938_REGTYPE, "V9_REG_PAGE2_EQBAND5", V9_REG_PAGE2_EQBAND5, 0, 0, "[29:25]: 4khz band"},
	{ V938_REGTYPE, "V9_REG_PAGE2_SAMP_RATE", V9_REG_PAGE2_SAMP_RATE, 0, 0, "[0] Sampling rate\n1¡¯b1: 48Khz\n1¡¯b0: 44.1khz\n[7:1] reserved"},
	{ V938_REGTYPE, "V9_REG_PAGE2_VOLSTEP", V9_REG_PAGE2_VOLSTEP, 0, 0, "[4:0]Volume step\n32 steps volume control signal. It represents 32 \nvolume control steps(0 ¨C31). 0 is the default value \nrepresenting no volume gain, 31 the maximum value for volume gain\n[7:5] reserved"},
	{ V938_REGTYPE, "V9_REG_PAGE2_OUTSEL", V9_REG_PAGE2_OUTSEL, 0, 0, "[0]:Output select\n1¡¯b1: bypass mode\n1¡¯b0: EQ mode\n[7:1] reserved"}
};

static const TRegUnit aesReg[] =
{
	{ V938_REGTYPE, "V9_REG_PAGE3_AES_CORE_CMD", V9_REG_PAGE3_AES_CORE_CMD, 0, 0, "aes core command\n[1:0]: aes core work mode\n2¡¯b00: aes core bypass mode\n2¡¯b01: reserved\n2¡¯b10: aes core decrypt ECB mode\n2¡¯b11: aes core decrypt CBC mode.\n[4:2]: reserved.\n[5]: reset aes core state\n 1¡¯b0: no effect\n 1¡¯b1: reset aes core state.\n[6]: aes_data_vld\n[7]: aes_busy"},
	{ V938_REGTYPE, "V9_REG_PAGE3_MP3_STRB_DLY", V9_REG_PAGE3_MP3_STRB_DLY, 0, 0, "[3:0]: DecStrb delay count\n4~15: width of DecStrb delay count is 4~15 mclk\n[7:4] reserved"},
	{ V938_REGTYPE, "V9_REG_PAGE3_AES_KEY0", V9_REG_PAGE3_AES_KEY0, 0, 0, "aes encrypt/decrypt key0"},
	{ V938_REGTYPE, "V9_REG_PAGE3_AES_KEY1", V9_REG_PAGE3_AES_KEY1, 0, 0, "aes encrypt/decrypt key1"},
	{ V938_REGTYPE, "V9_REG_PAGE3_AES_KEY2", V9_REG_PAGE3_AES_KEY2, 0, 0, "aes encrypt/decrypt key2"},
	{ V938_REGTYPE, "V9_REG_PAGE3_AES_KEY3", V9_REG_PAGE3_AES_KEY3, 0, 0, "aes encrypt/decrypt key3"},
	{ V938_REGTYPE, "V9_REG_PAGE3_AES_KEY4", V9_REG_PAGE3_AES_KEY4, 0, 0, "aes encrypt/decrypt key4"},
	{ V938_REGTYPE, "V9_REG_PAGE3_AES_KEY5", V9_REG_PAGE3_AES_KEY5, 0, 0, "aes encrypt/decrypt key5"},
	{ V938_REGTYPE, "V9_REG_PAGE3_AES_KEY6", V9_REG_PAGE3_AES_KEY6, 0, 0, "aes encrypt/decrypt key6"},
	{ V938_REGTYPE, "V9_REG_PAGE3_AES_KEY7", V9_REG_PAGE3_AES_KEY7, 0, 0, "aes encrypt/decrypt key7"},
	{ V938_REGTYPE, "V9_REG_PAGE3_AES_KEY8", V9_REG_PAGE3_AES_KEY8, 0, 0, "aes encrypt/decrypt key8"},
	{ V938_REGTYPE, "V9_REG_PAGE3_AES_KEY9", V9_REG_PAGE3_AES_KEY9, 0, 0, "aes encrypt/decrypt key9"},
	{ V938_REGTYPE, "V9_REG_PAGE3_AES_KEY10", V9_REG_PAGE3_AES_KEY10, 0, 0, "aes encrypt/decrypt key10"},
	{ V938_REGTYPE, "V9_REG_PAGE3_AES_KEY11", V9_REG_PAGE3_AES_KEY11, 0, 0, "aes encrypt/decrypt key11"},
	{ V938_REGTYPE, "V9_REG_PAGE3_AES_KEY12", V9_REG_PAGE3_AES_KEY12, 0, 0, "aes encrypt/decrypt key12"},
	{ V938_REGTYPE, "V9_REG_PAGE3_AES_KEY13", V9_REG_PAGE3_AES_KEY13, 0, 0, "aes encrypt/decrypt key13"},
	{ V938_REGTYPE, "V9_REG_PAGE3_AES_KEY14", V9_REG_PAGE3_AES_KEY14, 0, 0, "aes encrypt/decrypt key14"},
	{ V938_REGTYPE, "V9_REG_PAGE3_AES_KEY15", V9_REG_PAGE3_AES_KEY15, 0, 0, "aes encrypt/decrypt key15"},
	{ V938_REGTYPE, "V9_REG_PAGE3_AES_IV0", V9_REG_PAGE3_AES_IV0, 0, 0, "aes initial vector0"},
	{ V938_REGTYPE, "V9_REG_PAGE3_AES_IV1", V9_REG_PAGE3_AES_IV1, 0, 0, "aes initial vector1"},
	{ V938_REGTYPE, "V9_REG_PAGE3_AES_IV2", V9_REG_PAGE3_AES_IV2, 0, 0, "aes initial vector2"},
	{ V938_REGTYPE, "V9_REG_PAGE3_AES_IV3", V9_REG_PAGE3_AES_IV3, 0, 0, "aes initial vector3"},
	{ V938_REGTYPE, "V9_REG_PAGE3_AES_IV4", V9_REG_PAGE3_AES_IV4, 0, 0, "aes initial vector4"},
	{ V938_REGTYPE, "V9_REG_PAGE3_AES_IV5", V9_REG_PAGE3_AES_IV5, 0, 0, "aes initial vector5"},
	{ V938_REGTYPE, "V9_REG_PAGE3_AES_IV6", V9_REG_PAGE3_AES_IV6, 0, 0, "aes initial vector6"},
	{ V938_REGTYPE, "V9_REG_PAGE3_AES_IV7", V9_REG_PAGE3_AES_IV7, 0, 0, "aes initial vector7"},
	{ V938_REGTYPE, "V9_REG_PAGE3_AES_IV8", V9_REG_PAGE3_AES_IV8, 0, 0, "aes initial vector8"},
	{ V938_REGTYPE, "V9_REG_PAGE3_AES_IV9", V9_REG_PAGE3_AES_IV9, 0, 0, "aes initial vector9"},
	{ V938_REGTYPE, "V9_REG_PAGE3_AES_IV10", V9_REG_PAGE3_AES_IV10, 0, 0, "aes initial vector10"},
	{ V938_REGTYPE, "V9_REG_PAGE3_AES_IV11", V9_REG_PAGE3_AES_IV11, 0, 0, "aes initial vector11"},
	{ V938_REGTYPE, "V9_REG_PAGE3_AES_IV12", V9_REG_PAGE3_AES_IV12, 0, 0, "aes initial vector12"},
	{ V938_REGTYPE, "V9_REG_PAGE3_AES_IV13", V9_REG_PAGE3_AES_IV13, 0, 0, "aes initial vector13"},
	{ V938_REGTYPE, "V9_REG_PAGE3_AES_IV14", V9_REG_PAGE3_AES_IV14, 0, 0, "aes initial vector14"},
	{ V938_REGTYPE, "V9_REG_PAGE3_AES_IV15", V9_REG_PAGE3_AES_IV15, 0, 0, "aes initial vector15"}
};

static const TRegUnit sdReg[] =
{
	{ V938_REGTYPE, "V9_REG_PAGE4_SD_CMD0_FIFO", V9_REG_PAGE4_SD_CMD0_FIFO, 0, 0, "SD card writing/reading cmd0 port"},
	{ V938_REGTYPE, "V9_REG_PAGE4_SD_CMD1_FIFO", V9_REG_PAGE4_SD_CMD1_FIFO, 0, 0, "SD card writing/reading cmd1 port"},
	{ V938_REGTYPE, "V9_REG_PAGE4_SD_DATA_FIFO", V9_REG_PAGE4_SD_DATA_FIFO, 0, 0, "SD card writing/reading data port"}
};

static const TRegUnit ledReg[] =
{
	{ V938_REGTYPE, "V9_REG_PAGE5_REG_TIMESLICE_HIGH", V9_REG_PAGE5_REG_TIMESLICE_HIGH, 0, 0, "The high 8 bits of time slice period*"},
	{ V938_REGTYPE, "V9_REG_PAGE5_REG_TIMESLICE_LOW", V9_REG_PAGE5_REG_TIMESLICE_LOW, 0, 0, "The low 8 bits of time slice period*"},
	{ V938_REGTYPE, "V9_REG_PAGE5_REG_PWM_RLED_HIGH", V9_REG_PAGE5_REG_PWM_RLED_HIGH, 0, 0, "The high 8 bits of pwm period for red led*"},
	{ V938_REGTYPE, "V9_REG_PAGE5_REG_PWM_RLED_LOW", V9_REG_PAGE5_REG_PWM_RLED_LOW, 0, 0, "The low 8 bits of pwm period for red led*"},
	{ V938_REGTYPE, "V9_REG_PAGE5_REG_PWM_BLED_HIGH", V9_REG_PAGE5_REG_PWM_BLED_HIGH, 0, 0, "The high 8 bits of pwm period for blue led*"},
	{ V938_REGTYPE, "V9_REG_PAGE5_REG_PWM_BLED_LOW", V9_REG_PAGE5_REG_PWM_BLED_LOW, 0, 0, "The low 8 bits of pwm period for blue led*"},
	{ V938_REGTYPE, "V9_REG_PAGE5_REG_PWM_GLED_HIGH", V9_REG_PAGE5_REG_PWM_GLED_HIGH, 0, 0, "The high 8 bits of pwm period for green led*"},
	{ V938_REGTYPE, "V9_REG_PAGE5_REG_PWM_GLED_LOW", V9_REG_PAGE5_REG_PWM_GLED_LOW, 0, 0, "The low 8 bits of pwm period for green led*"},
	{ V938_REGTYPE, "V9_REG_PAGE5_REG_PWM_MOT_HIGH", V9_REG_PAGE5_REG_PWM_MOT_HIGH, 0, 0, "The high 8 bits of pwm period for mot*"},
	{ V938_REGTYPE, "V9_REG_PAGE5_REG_PWM_MOT_LOW", V9_REG_PAGE5_REG_PWM_MOT_LOW, 0, 0, "The low 8 bits of pwm period for mot*"},
	{ V938_REGTYPE, "V9_REG_PAGE5_REG_LEDMOT_CONF", V9_REG_PAGE5_REG_LEDMOT_CONF, 0, 0, "Letmot configuration register"},
	{ V938_REGTYPE, "V9_REG_PAGE5_REG_CIRCLING_PERIOD", V9_REG_PAGE5_REG_CIRCLING_PERIOD, 0, 0, "Circling period under unconditional and \nconditional circling "},
	{ V938_REGTYPE, "V9_REG_PAGE5_REG_INDEX", V9_REG_PAGE5_REG_INDEX, 0, 0, "Index is set by software under customer mode"},
	{ V938_REGTYPE, "V9_REG_PAGE5_REG_PATTERN0_HIGH", V9_REG_PAGE5_REG_PATTERN0_HIGH, 0, 0, "Color define when index equals 0"},
	{ V938_REGTYPE, "V9_REG_PAGE5_REG_PATTERN0_LOW", V9_REG_PAGE5_REG_PATTERN0_LOW, 0, 0, "Color define when index equals 0"},
	{ V938_REGTYPE, "V9_REG_PAGE5_REG_PATTERN1_HIGH", V9_REG_PAGE5_REG_PATTERN1_HIGH, 0, 0, "Color define when index equals 1"},
	{ V938_REGTYPE, "V9_REG_PAGE5_REG_PATTERN1_LOW", V9_REG_PAGE5_REG_PATTERN1_LOW, 0, 0, "Color define when index equals 1"},
	{ V938_REGTYPE, "V9_REG_PAGE5_REG_PATTERN2_HIGH", V9_REG_PAGE5_REG_PATTERN2_HIGH, 0, 0, "Color define when index equals 2"},
	{ V938_REGTYPE, "V9_REG_PAGE5_REG_PATTERN2_LOW", V9_REG_PAGE5_REG_PATTERN2_LOW, 0, 0, "Color define when index equals 2"},
	{ V938_REGTYPE, "V9_REG_PAGE5_REG_PATTERN3_HIGH", V9_REG_PAGE5_REG_PATTERN3_HIGH, 0, 0, "Color define when index equals 3"},
	{ V938_REGTYPE, "V9_REG_PAGE5_REG_PATTERN3_LOW", V9_REG_PAGE5_REG_PATTERN3_LOW, 0, 0, "Color define when index equals 3"},
	{ V938_REGTYPE, "V9_REG_PAGE5_REG_PATTERN4_HIGH", V9_REG_PAGE5_REG_PATTERN4_HIGH, 0, 0, "Color define when index equals 4"},
	{ V938_REGTYPE, "V9_REG_PAGE5_REG_PATTERN4_LOW", V9_REG_PAGE5_REG_PATTERN4_LOW, 0, 0, "Color define when index equals 4"},
	{ V938_REGTYPE, "V9_REG_PAGE5_REG_PATTERN5_HIGH", V9_REG_PAGE5_REG_PATTERN5_HIGH, 0, 0, "Color define when index equals 5"},
	{ V938_REGTYPE, "V9_REG_PAGE5_REG_PATTERN5_LOW", V9_REG_PAGE5_REG_PATTERN5_LOW, 0, 0, "Color define when index equals 5"},
	{ V938_REGTYPE, "V9_REG_PAGE5_REG_PATTERN6_HIGH", V9_REG_PAGE5_REG_PATTERN6_HIGH, 0, 0, "Color define when index equals 6"},
	{ V938_REGTYPE, "V9_REG_PAGE5_REG_PATTERN6_LOW", V9_REG_PAGE5_REG_PATTERN6_LOW, 0, 0, "Color define when index equals 6"},
	{ V938_REGTYPE, "V9_REG_PAGE5_REG_PATTERN7_HIGH", V9_REG_PAGE5_REG_PATTERN7_HIGH, 0, 0, "Color define when index equals 7"},
	{ V938_REGTYPE, "V9_REG_PAGE5_REG_PATTERN7_LOW", V9_REG_PAGE5_REG_PATTERN7_LOW, 0, 0, "Color define when index equals 7"},
	{ V938_REGTYPE, "V9_REG_PAGE5_REG_MTRCTRL", V9_REG_PAGE5_REG_MTRCTRL, 0, 0, "BIT1- Bit 0: MODE, Select mode external motor control.\nBIT3- Bit 2: LW, The low level width of waveform at \nmode 2 (asynchronous or synchronous).\nBIT5- Bit 4: HW, The high level width of waveform at \nmode 2 (asynchronous or synchronous)\nBIT6: reserved\nBIT7: OUT, This is the bit used in the asynchronous mode 1 and 2"},
	{ V938_REGTYPE, "V9_REG_PAGE5_REG_MTRSYNC", V9_REG_PAGE5_REG_MTRSYNC, 0, 0, "BIT6- Bit 0: MTR_SYNCCH, setting channels correspond \n  with play data\nBIT7: 1¡¯b1 enable test simulation fast,1¡¯b0 normal function "},
	{ V938_REGTYPE, "V9_REG_PAGE5_REG_LEDCTRL1", V9_REG_PAGE5_REG_LEDCTRL1, 0, 0, "BIT1- Bit 0: MODE, Select mode LED on/off control.\nBIT4- Bit 2: FREQ, Set frequency of output signal \nusing in asynchronous mode 2 and synchronous mode with play data 2.\nDuty of H period and L is 50%.\nBIT6- Bit 5: GTON, The minimum time of GateTimeON\nBIT7: OUT, This is the bit used in the asynchronous mode 1 and 2"},
	{ V938_REGTYPE, "V9_REG_PAGE5_REG_LEDCTRL2", V9_REG_PAGE5_REG_LEDCTRL2, 0, 0, "BIT1- Bit 0: MODE, Select mode LED on/off control.\nBIT4- Bit 2: FREQ, Set frequency of output signal \nusing in asynchronous mode 2 and synchronous mode \nwith play data 2.Duty of H period and L is 50%.\nBIT6- Bit 5: GTON, The minimum time of GateTimeON\nBIT7: OUT, This is the bit used in the asynchronous mode 1 and 2"},
	{ V938_REGTYPE, "V9_REG_PAGE5_REG_LEDCTRL3", V9_REG_PAGE5_REG_LEDCTRL3, 0, 0, ""},
	{ V938_REGTYPE, "V9_REG_PAGE5_REG_LEDSYNC1", V9_REG_PAGE5_REG_LEDSYNC1, 0, 0, "BIT6- Bit 0: LED_SYNCCH, setting channels correspond with play data \nBIT7: 1¡¯b1 enable test simulation fast,1¡¯b0 normal function"},
	{ V938_REGTYPE, "V9_REG_PAGE5_REG_LEDSYNC2", V9_REG_PAGE5_REG_LEDSYNC2, 0, 0, ""},
	{ V938_REGTYPE, "V9_REG_PAGE5_REG_LEDSYNC3", V9_REG_PAGE5_REG_LEDSYNC3, 0, 0, ""},
};

const TRegList gV938Reglist[] =
{
	{ "CPM Reg",             (PTRegUnit)cpmReg,        sizeof(cpmReg) / sizeof(TRegUnit) },
	{ "Global Control Reg",  (PTRegUnit)globalCtrReg,  sizeof(globalCtrReg) / sizeof(TRegUnit) },
	{ "FIFO Write Reg",      (PTRegUnit)fifoWrReg,     sizeof(fifoWrReg) / sizeof(TRegUnit) },
	{ "Channel Reg",         (PTRegUnit)chanCtrReg,    sizeof(chanCtrReg) / sizeof(TRegUnit) },
	{ "Audio Reg",           (PTRegUnit)audioCtrReg,   sizeof(audioCtrReg) / sizeof(TRegUnit) },
	{ "MP3 Reg",             (PTRegUnit)mp3Reg,        sizeof(mp3Reg) / sizeof(TRegUnit) },
	{ "EQ Reg",              (PTRegUnit)eqReg,         sizeof(eqReg) / sizeof(TRegUnit) },
	{ "AES Reg",             (PTRegUnit)aesReg,        sizeof(aesReg) / sizeof(TRegUnit) },
	{ "SD Access Reg",       (PTRegUnit)sdReg,         sizeof(sdReg) / sizeof(TRegUnit) },
	{ "LED Reg",             (PTRegUnit)ledReg,        sizeof(ledReg) / sizeof(TRegUnit) },
};


const int gV938ReglistCount = sizeof(gV938Reglist) / sizeof(TRegList);





