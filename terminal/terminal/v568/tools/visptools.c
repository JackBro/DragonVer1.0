#include "internal.h"

static void	VAeFomula(PTAeAdjust ae, UINT8 flag);
static UINT8 VAeIsGainOnly(PTAeAdjust ae);
static UINT32 VBComputeGain(UINT8 gain, UINT8 preY, UINT8 newY);
static void VBOneStepMore(PTAeAdjust ae);
static void VBOneStepLess(PTAeAdjust ae);
static void VBEtRangeAdjust(PTAeAdjust ae);

/*******************************************************************
log table, generated by log generator
all data are recorded in 3.13 fix point format
For example:
log[13] = 2.5649493574615367360534874415653

then
2.5649493574615367360534874415653 * 2^13 = 21012 = 0x5214;

so:
gLogTable[13]= 0x5214;

Version 0.1
Creator: Sandman
*********************************************************************/
static const UINT16 gLogTable[257] = {
	0x0, 0x0, 0x162e, 0x2327, 0x2c5c, 0x3380, 0x3956, 0x3e44, 0x428a, 0x464f, 0x49ae, 0x4cbb, 0x4f84, 0x5214, 0x5473, 0x56a8, 0x58b9,
	0x5aa9, 0x5c7d, 0x5e38, 0x5fdd, 0x616c, 0x62e9, 0x6455, 0x65b2, 0x6701, 0x6842, 0x6977, 0x6aa1, 0x6bc0, 0x6cd6, 0x6de3, 0x6ee7,
	0x6fe3, 0x70d7, 0x71c5, 0x72ac, 0x738c, 0x7467, 0x753b, 0x760b, 0x76d5, 0x779a, 0x785b, 0x7918, 0x79d0, 0x7a84, 0x7b34, 0x7be0,
	0x7c89, 0x7d2f, 0x7dd1, 0x7e70, 0x7f0c, 0x7fa5, 0x803c, 0x80cf, 0x8160, 0x81ef, 0x827b, 0x8304, 0x838c, 0x8411, 0x8494, 0x8515,
	0x8594, 0x8611, 0x868c, 0x8706, 0x877d, 0x87f3, 0x8867, 0x88da, 0x894b, 0x89ba, 0x8a28, 0x8a95, 0x8b00, 0x8b6a, 0x8bd2, 0x8c39,
	0x8c9f, 0x8d03, 0x8d67, 0x8dc9, 0x8e2a, 0x8e8a, 0x8ee8, 0x8f46, 0x8fa2, 0x8ffe, 0x9058, 0x90b2, 0x910b, 0x9162, 0x91b9, 0x920f,
	0x9264, 0x92b8, 0x930b, 0x935d, 0x93af, 0x93ff, 0x944f, 0x949e, 0x94ed, 0x953a, 0x9587, 0x95d4, 0x961f, 0x966a, 0x96b4, 0x96fd,
	0x9746, 0x978e, 0x97d6, 0x981d, 0x9863, 0x98a9, 0x98ee, 0x9933, 0x9977, 0x99ba, 0x99fd, 0x9a3f, 0x9a81, 0x9ac2, 0x9b03, 0x9b43,
	0x9b83, 0x9bc2, 0x9c01, 0x9c3f, 0x9c7d, 0x9cbb, 0x9cf8, 0x9d34, 0x9d70, 0x9dac, 0x9de7, 0x9e21, 0x9e5c, 0x9e96, 0x9ecf, 0x9f08,
	0x9f41, 0x9f79, 0x9fb1, 0x9fe9, 0xa020, 0xa057, 0xa08d, 0xa0c3, 0xa0f9, 0xa12e, 0xa163, 0xa198, 0xa1cc, 0xa200, 0xa234, 0xa267,
	0xa29a, 0xa2cd, 0xa300, 0xa332, 0xa363, 0xa395, 0xa3c6, 0xa3f7, 0xa428, 0xa458, 0xa488, 0xa4b8, 0xa4e7, 0xa516, 0xa545, 0xa574,
	0xa5a3, 0xa5d1, 0xa5ff, 0xa62c, 0xa65a, 0xa687, 0xa6b4, 0xa6e0, 0xa70d, 0xa739, 0xa765, 0xa790, 0xa7bc, 0xa7e7, 0xa812, 0xa83d,
	0xa867, 0xa892, 0xa8bc, 0xa8e6, 0xa910, 0xa939, 0xa962, 0xa98b, 0xa9b4, 0xa9dd, 0xaa05, 0xaa2e, 0xaa56, 0xaa7d, 0xaaa5, 0xaacd,
	0xaaf4, 0xab1b, 0xab42, 0xab69, 0xab8f, 0xabb6, 0xabdc, 0xac02, 0xac28, 0xac4d, 0xac73, 0xac98, 0xacbd, 0xace2, 0xad07, 0xad2c,
	0xad50, 0xad75, 0xad99, 0xadbd, 0xade1, 0xae04, 0xae28, 0xae4b, 0xae6e, 0xae91, 0xaeb4, 0xaed7, 0xaefa, 0xaf1c, 0xaf3f, 0xaf61,
	0xaf83, 0xafa5, 0xafc7, 0xafe8, 0xb00a, 0xb02b, 0xb04c, 0xb06e, 0xb08e, 0xb0af, 0xb0d0, 0xb0f1, 0xb111, 0xb131, 0xb152, 0xb172
};

static const TAeStep gAeStep[] = 
{
	{4, 4},			//slow
	{4, 3},			//normal
	{4, 2},			//fast
	{4, 1}			//fastest
};

static UINT8 gGainRange[ET_GAINRANGE_STEP];
static UINT8 VBGetGainRange(UINT8 step);

UINT16	MaxDivisor(UINT16 a, UINT16 b)
{
	while(a && b)
	{
		if(a > b)
			a %= b;
		else
			b %= a;
	}
	if(a)
		return a;
	return b;
}

UINT32 Vabs(SINT32 x)
{
	if(x<0)
		return -x;
	else
		return x;
}

void CalculateNewGammaCurve( UINT8 * OriginalGammaCurve, 
									SINT16 DeltaContrast, 
									SINT16 DeltaBrightness, 
									UINT8 * NewGammaCurve	 )
{
	SINT16 deltaGma[17] ;
	SINT16 steps = DeltaContrast ;
	SINT16 i, temp ;

	// step 1: Calculate deltaGma[] based on DeltaContrast
	// for simplicity, all the division is based on 64(can be done by >>8 )
	deltaGma[0] = 0 ;
	deltaGma[1] = - 96 * steps / 64 ;
	deltaGma[3] = - 72 * steps / 64 ;
	deltaGma[6] = 0 ;
	deltaGma[11] = 146 * steps / 64 ;
	deltaGma[16] = 166 * steps / 64 ;
	
	deltaGma[2] = ( deltaGma[1] + deltaGma[3] ) / 2 ;
	
	deltaGma[4] = - 72 * (6-4) * steps / (6-3) / 64 ;
	deltaGma[5] = - 72 * (6-5) * steps / (6-3) / 64 ;
	
	deltaGma[7] =  146 * (7-6) * steps / (11-6) / 64 ;
	deltaGma[8] =  146 * (8-6) * steps / (11-6) / 64 ;
	deltaGma[9] =  146 * (9-6) * steps / (11-6) / 64 ;
	deltaGma[10] = 146 * (10-6) * steps / (11-6) / 64 ;
	
	deltaGma[12] = deltaGma[11] + (deltaGma[16]-deltaGma[11]) * (12-11) / (16-11) ;
	deltaGma[13] = deltaGma[11] + (deltaGma[16]-deltaGma[11]) * (13-11) / (16-11) ;
	deltaGma[14] = deltaGma[11] + (deltaGma[16]-deltaGma[11]) * (14-11) / (16-11) ;
	deltaGma[15] = deltaGma[11] + (deltaGma[16]-deltaGma[11]) * (15-11) / (16-11) ;
	
	// step 2: update deltaGma[] based on DeltaBrightness
	for ( i = 0 ; i < 17; i ++ )
		deltaGma[i] += DeltaBrightness * 5 ;
	
	// step 3: Calculate NewGammaCurve
	for ( i = 0 ; i < 17; i ++ )
	{
		temp = OriginalGammaCurve[i] + deltaGma[i] ;
		if ( temp < 0 ) 
			temp = 0 ;
		else 
			if ( temp > 255 )
				temp = 255 ;  
			NewGammaCurve[i] = (UINT8)temp ;
	}
}

UINT32 PowTwo(UINT32 x, UINT16 y, UINT8 denominator, UINT8 numerator)
{
	UINT16 i;

	for(i = 0; i < y; i++)
	{
		x *= numerator;
		x /= denominator;
	}

	return x;
}

/**********************************************************************
	Description:	Square root
	Parameter:		UINT32
	Return:			UINT16
****************************************/
UINT16 vsqrt(UINT32 M)
{
    UINT16 N, i;
    UINT32 tmp, ttp;

    if (M == 0)               
        return 0;

    N = 0;

    tmp = (M >> 30);          // get highest bit:B[m-1]
    M <<= 2;
    if (tmp > 1)              // highest bit is 1
    {
        N ++;                 // result current bit = 1,otherwise = 0
        tmp -= N;
    }

    for (i = 15; i > 0; i--)      // get remain 15 bits
    {
        N <<= 1;              // left move 1 bit

        tmp <<= 2;
        tmp += (M >> 30);     

        ttp = N;
        ttp = (ttp<<1)+1;

        M <<= 2;
        if (tmp >= ttp)       
        {
            tmp -= ttp;
            N ++;
        }

    }

    return N;
}

/********************************************************************************
	Description:
		get destinate size and zoom ratio
	Returns:
	Note:
	Remarks:
*********************************************************************************/
void VComputerParm(TSize src, UINT16 width, TSize *dst, TV5BIppFactor *fct)
{
	UINT16 tempY;
	UINT32 temp;

	/* if width > src.cx ,image is zoom in 
	if(width > src.cx)
		width = src.cx;
	*/
	if((width == 0) || (src.cx == 0))
		return;
	temp = ((src.cx % width)<<10)/width;
	fct->intValue = (UINT8)(src.cx /width);
	fct->decValue = (UINT16)(temp);
    
	temp = src.cy * width;
	tempY = (UINT16)(temp/src.cx);
	width = (width>>1)<<1;
	tempY = (tempY>>1)<<1;
	dst->cx = width;
	dst->cy = tempY;
}

/********************************************************************************
	Description:
		get destinate size and zoom ratio(By height)
	Returns:
	Note:
	Remarks:
*********************************************************************************/
void VComputerParmH(TSize src, UINT16 height, TSize *dst, TV5BIppFactor *fct)
{
	UINT16 tempX;
	UINT32 temp;

	/* if width > src.cx ,image is zoom in 
	if(width > src.cx)
		width = src.cx;
	*/
	if((height == 0) || (src.cy == 0))
		return;
	temp = ((src.cy % height)<<10)/height;
	fct->intValue = (UINT8)(src.cy /height);
	fct->decValue = (UINT16)(temp);
    
	temp = src.cx * height;
	tempX = (UINT16)(temp/src.cy);
	height = (height>>1)<<1;
	tempX = (tempX>>1)<<1;
	dst->cx = tempX;
	dst->cy = height;
}

/********************************************************************************
	Description:
		get destinate size
	Returns:
	Note:
	Remarks:
*********************************************************************************/
void VComputerSizeByWidth(TSize src, UINT16 width, TSize *dst)
{
	UINT16 tempY;
	UINT32 temp;

	if((width == 0) || (src.cx == 0))
		return;
	temp = ((src.cx % width)<<10)/width;
	temp = src.cy * width;
	tempY = (UINT16)(temp/src.cx);
	width = (width>>1)<<1;
	tempY = (tempY>>1)<<1;
	dst->cx = width;
	dst->cy = tempY;
}

/********************************************************************************
	Description:
		get destinate size (By height)
	Returns:
	Note:
	Remarks:
*********************************************************************************/
void VComputerSizeByHeight(TSize src, UINT16 height, TSize *dst)
{
	UINT16 tempX;
	UINT32 temp;

	if((height == 0) || (src.cy == 0))
		return;
	temp = ((src.cy % height)<<10)/height;
	temp = src.cx * height;
	tempX = (UINT16)(temp/src.cy);
	height = (height>>1)<<1;
	tempX = (tempX>>1)<<1;
	dst->cx = tempX;
	dst->cy = height;
}

/*************************************************************************************************
	Descriptin:	Compute exposure time 
	Return: FAILED -- error
			GAIN_ONLY -- just change gain value
			GAIN_ET -- change gain and et
			UN_ET_GAIN	-- don't change gain and et
	Remarks:new gain is set to ae->gtarget, new et is set to ae->et
*************************************************************************************************/
UINT8 VComputeEt(PTAeAdjust ae)
{
	UINT8 ret;

	if(ae == NULL)
		return FAILED;

	ret = VAeIsGainOnly(ae);
	if(ret == TRUE)
		return GAIN_ONLY;
	
	VAeFomula(ae, AE_GET_ET);
	
	if(ae->newet >= ET_ONE_STEP)
		VBOneStepMore(ae);
	else			//new et < one_step
		VBOneStepLess(ae);

	VBEtRangeAdjust(ae);

	ae->gthd = VBGetGainRange((UINT8)(ae->newet/ET_ONE_STEP));
	VAeFomula(ae, AE_GET_GAIN);
	
	return GAIN_ET;
}

/*************************************************************************************************
	Descriptin:	AE Compute Fomula
	Para:		ae:		structure of ae 
				flag:	AE_GET_ET
						AE_GET_GAIN
	Remarks:new gain is set to ae->gtarget
*************************************************************************************************/
void VAeFomula(PTAeAdjust ae, UINT8 flag)
{
	UINT32 temp;
	UINT32 preet, newet;
	UINT8 pregain, newgain;

	if(ae == NULL)
		return;

	preet = (ae->snrclock / ae->freq) * ae->et;
	newet = (ae->snrclock / ae->freq) * ae->newet;
	pregain = ae->gain;
	newgain = ae->gtarget;

	if(ae->ymean == 0)
		temp = (UINT32)(gLogTable[AE_M] - gLogTable[AE_M-1]);
	else
		temp = (UINT32)(gLogTable[AE_M] - gLogTable[AE_M-ae->ymean]);
	temp = temp << 10;
	temp = (UINT32)(temp / (gLogTable[AE_M] - gLogTable[AE_M-ae->ytarget]));
	
	if(flag == AE_GET_GAIN)
	{
		newgain = (UINT8)((preet * pregain) / ((temp * newet) >> 10));
		if(newgain < ae->gtarget - ae->gthd)
			ae->gtarget = ae->gtarget - ae->gthd;
		else if(newgain > ae->gtarget + ae->gthd)
			ae->gtarget = ae->gtarget + ae->gthd;
		else
			ae->gtarget = newgain;

		if((ae->newet == ((UINT32)ae->maxet * ET_ONE_STEP)) && (ae->ymean < ae->ytarget))
			ae->gtarget = ae->maxgain;
	}
	else if(flag == AE_GET_ET)
	{
		newet = ((UINT32)(preet * pregain) / (temp * newgain)) << 10;
		ae->newet = newet/(ae->snrclock/ae->freq);
	}
}

UINT8 VAeIsGainOnly(PTAeAdjust ae)
{
	UINT8 gainUp, gainDown;
	UINT32 tempGain;

	gainUp = ae->gtarget + ae->gthd;
	gainDown = ae->gtarget - ae->gthd;
	if(ae->et == ET_ONE_STEP)
		gainDown = (ae->mingain < gainDown) ? ae->mingain : gainDown;
	if(ae->et == (UINT32)(ae->maxet * ET_ONE_STEP))
		gainUp = (ae->maxgain > gainUp) ? ae->maxgain : gainUp;
	
	tempGain = VBComputeGain(ae->gain, ae->ymean, ae->ytarget);
	
	if(tempGain > (UINT32)gainUp)
	{
		tempGain = VBComputeGain(ae->gain, ae->ymean, ae->ytarget-ae->ythd);
		if(tempGain > (UINT32)gainUp)
			return FALSE;
	}
	else if(tempGain < (UINT32)gainDown)
	{
		tempGain = VBComputeGain(ae->gain, ae->ymean, ae->ytarget+ae->ythd);
		if(tempGain < (UINT32)gainDown)
			return FALSE;
	}

	ae->gtarget = (UINT8)tempGain;
	return TRUE;
}

UINT32 VBComputeGain(UINT8 gain, UINT8 preY, UINT8 newY)
{
	UINT32 temp;

	newY = (newY + preY)/2;
	temp = (UINT32)(gLogTable[AE_M] - gLogTable[AE_M-newY]);
	temp = temp << 10;
	if(preY == 0)
		temp = (UINT32)(temp / (gLogTable[AE_M] - gLogTable[AE_M-1]));
	else
		temp = (UINT32)(temp / (gLogTable[AE_M] - gLogTable[AE_M-preY]));
	temp = (temp * gain)>>10;
	
	return temp;
}

void VComputeGainThd(UINT8 gain, UINT8 gainrange)
{
	UINT8 i;

	memset(gGainRange, 0, sizeof(gGainRange));

	gGainRange[0] = gainrange;

	for(i = 1; i < ET_GAINRANGE_STEP; i++)
		gGainRange[i] = gain - ((gGainRange[i-1]+gain)*i)/(i+1) + ET_GAINRANGE_OVERLAY;

	return;
}

UINT8 VBGetGainRange(UINT8 step)
{
	UINT8 gainrange;

	if(step > ET_GAINRANGE_STEP)
		gainrange = gGainRange[ET_GAINRANGE_STEP-1];
	else if(step == 0)
		gainrange = 0;
	else
		gainrange = gGainRange[step-1];

	return gainrange;
}

void VBOneStepMore(PTAeAdjust ae)
{
	UINT32 etjump;

	if(ae->newet > ae->et)
	{
		etjump = ae->newet-ae->et;
		if(etjump < (UINT32)(gAeStep[ae->speed].step * ET_ONE_STEP))
			ae->newet = ae->et + ET_ONE_STEP;
		else
			ae->newet = ae->et + (etjump / gAeStep[ae->speed].div) - 
						((etjump / gAeStep[ae->speed].div) % ET_ONE_STEP);
	}
	else
	{
		etjump = ae->et - ae->newet;
		if((etjump != 0) && ((ae->et) > ET_ONE_STEP))
		{
			if(etjump < (UINT32)(gAeStep[ae->speed].step * ET_ONE_STEP))
				ae->newet = ae->et - ET_ONE_STEP;
			else if(etjump > ((UINT32)ae->maxet * ET_ONE_STEP / 3))			//hx: 3 should be define
				ae->newet = ae->newet + (gAeStep[ae->speed].step * ET_ONE_STEP);
			else
				ae->newet = (ae->et) - (etjump / (gAeStep[ae->speed].div)) +
							((etjump / (gAeStep[ae->speed].div)) % ET_ONE_STEP);
		}
	}
}

void VBOneStepLess(PTAeAdjust ae)
{
	UINT32 etjump;

	if((ae->et) > ET_ONE_STEP)
	{
		etjump = ae->et - ET_ONE_STEP;
		if(etjump < (UINT32)(gAeStep[ae->speed].step * ET_ONE_STEP))
			ae->newet = ae->et - ET_ONE_STEP;
		else if(etjump > ((UINT32)ae->maxet * ET_ONE_STEP / 3))			//hx: 3 should be define
			ae->newet = ae->newet + (gAeStep[ae->speed].step * ET_ONE_STEP);
		else
			ae->newet = (ae->et) - (etjump / (gAeStep[ae->speed].div)) +
						((etjump / (gAeStep[ae->speed].div)) % ET_ONE_STEP);
	}
	else if((ae->et == ET_ONE_STEP) && (ae->ymean <= ae->ytop))
	{
		ae->newet = ae->et;
		ae->gtarget = ae->gain;
	}
}

void VBEtRangeAdjust(PTAeAdjust ae)
{
	UINT32 tempDec = 0;

	if(ae->newet > ET_ONE_STEP)	//indoor
	{
		tempDec = ((ae->newet) % ET_ONE_STEP);
		if(tempDec <= (ET_ONE_STEP >> 1))
			ae->newet = ae->newet - tempDec;
		else
			ae->newet = ae->newet + ET_ONE_STEP - tempDec;
	}

	if((ae->newet) > ((UINT32)ae->maxet * ET_ONE_STEP))
		ae->newet = (ae->maxet * ET_ONE_STEP);
	if((ae->newet) < ((UINT32)ae->minet * ET_ONE_STEP))
		ae->newet = ae->minet * ET_ONE_STEP;
	if(ae->newet == 0)
		ae->newet = 1;
}

/*********************************************************************
*                    Tools For VC0578 IPP Sizer                      *
*********************************************************************/

static void VCalcSizerUpFactor(UINT16 src, UINT16 dst, PTV5BIppSzUpFct pfct)
{
	UINT32 tmps = 0, tmpd = 0, maxdiv = 0;

	maxdiv = MaxDivisor(src, dst);
	tmps = src / maxdiv;
	tmpd = dst / maxdiv;
	if(tmpd > 0x100)
	{
		tmps = (tmps << 8) / tmpd;
		tmpd = 0x100;
	}
	if(tmps == tmpd)
		tmps --;
	pfct->w1 = (UINT8)tmps;
	pfct->w2 = (UINT8)tmpd;
	pfct->s  = (UINT16)(0x10000 / tmpd);
}

void VCalcSizerUpHPara(TSize ssize, UINT16 width, PTSize pdsize, PTV5BIppSzUpFct pfct)
{
	if((ssize.cx == 0) || (width == 0) || (width < ssize.cx)
		|| (pdsize == NULL) || (pfct == NULL))
		return;
	width = (width >> 1) << 1;
	VCalcSizerUpFactor(ssize.cx, width, pfct);
	pdsize->cx = width;
	pdsize->cy = (UINT16)(((ssize.cy * width / ssize.cx) >> 1) << 1);
}

void VCalcSizerUpVPara(TSize ssize, UINT16 height, PTSize pdsize, PTV5BIppSzUpFct pfct)
{
	if((ssize.cy == 0) || (height == 0) || (height < ssize.cy)
		|| (pdsize == NULL) || (pfct == NULL))
		return;
	height = (height >> 1) << 1;
	VCalcSizerUpFactor(ssize.cy, height, pfct);
	pdsize->cx = (UINT16)(((ssize.cx * height / ssize.cy) >> 1) << 1);
	pdsize->cy = height;
}

static void VCalcSizerDownFactor(UINT16 src, UINT16 dst, PTV5BIppSzDnFct pfct)
{
	UINT32 tmps = 0, tmpd = 0, maxdiv = 0;

	maxdiv = MaxDivisor(src, dst);
	tmps = src / maxdiv;
	tmpd = dst / maxdiv;
	if(tmps > 0x80)
	{
		tmpd = (tmpd << 7) / tmps + 1;
		tmps = 0x80;
	}
	pfct->w1 = (UINT8)(tmps & 0x7f);
	pfct->w2 = (UINT8)(tmpd & 0x7f);
	pfct->s1 = (UINT16)(tmps / tmpd);
	pfct->s2 = (UINT16)(pfct->s1 + ((tmps % tmpd) ? 1 : 0));
	pfct->s1 = (UINT16)(0x10000 / pfct->s1);
	pfct->s2 = (UINT16)(0x10000 / pfct->s2);
	pfct->c  = (UINT8)(tmpd - (tmps % tmpd));
}

void VCalcSizerDownHPara(TSize ssize, UINT16 width, PTSize pdsize, PTV5BIppSzDnFct pfct)
{
	if((ssize.cx == width) || (ssize.cx == 0) || (width == 0) || (ssize.cx < width)
		|| (pdsize == NULL) || (pfct == NULL))
		return;
	width = (width >> 1) << 1;
	VCalcSizerDownFactor(ssize.cx, width, pfct);
	pdsize->cx = width;
	pdsize->cy = (UINT16)(((ssize.cy * width / ssize.cx) >> 1) << 1);
}

void VCalcSizerDownVPara(TSize ssize, UINT16 height, PTSize pdsize, PTV5BIppSzDnFct pfct)
{
	if((ssize.cy == height) || (ssize.cy == 0) || (height == 0) || (ssize.cy < height)
		|| (pdsize == NULL) || (pfct == NULL))
		return;
	height = (height >> 1) << 1;
	VCalcSizerDownFactor(ssize.cy, height, pfct);
	pdsize->cx = (UINT16)(((ssize.cx * height / ssize.cy) >> 1) << 1);
	pdsize->cy = height;
}
