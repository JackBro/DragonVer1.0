/*------------------------------------------------------------------------

				COPYRIGHT (C) 2004, Vimicro Corporation
                        	ALL RIGHTS RESERVED

	This source code has been made available to you by VIMICRO on an 
	AS-IS basis. Anyone receiving this source code is licensed under
	VIMICRO copyrights to use it in any way he or she deems fit, including 
	copying it,  modifying it, compiling it, and redistributing it either
	with or without  modifications. Any person who transfers this source 
	code or any derivative  work must include the VIMICRO copyright notice 
	and	this paragraph in the transferred software.

	Version		Description        					Date         	Author

	1.0			Basic version						2005.03.18	Zxh

				
-------------------------------------------------------------------------*/

#include "vmd.h"
//#include "vxmf.h"
#include "vparser.h"

#if VMD_PARSER_XMF_SUPPORT


static XMFMIDIFILETRACK 	g_MidiTrack[MAX_MIDITRACK];
static XMFMIDIFILETRACK   g_TrackInfoBak[MAX_MIDITRACK];
static MIDI_CHN_INFO	g_ChnInfo[MAX_MIDI_CHN];
static VM_UNI_MSG	g_MsgQue[MAX_MIDI_CHN*8]; //Store the msg generated by VXmf_Seek();
static UINT8	g_MsgQueNum;	 //Number of Msg in MsgQue;
static UINT32	g_dwTotalTime;
static UINT8	g_TrackNum;
static UINT32	g_dwTicksPerQN;
static UINT32	g_dwTempoMS;
static UINT32	g_dwTrackEnd;
static UINT8	g_MidiFmt;
static UINT32 	g_dwPreTime;
static UINT32	g_dwCurTime;
static UINT32	g_dwCurTick;//previous msg tick
static UINT8	g_msgBuf[5];
static UINT16	g_RPN[MAX_MIDI_CHN];	
static UINT8	g_bEndFlag;
static UINT32	g_SeekOverTime;

static UINT8	*g_pXmfFilePtr;
static UINT32	g_dwXmfLen;

static UINT8 g_bSelect;
static UINT8 g_bSize;

static XMFDATA _FAR g_XmfData[MAX_SMF_NUM];
//static METADATATYPETABLE g_MetaDataTable;
static FILEHEADER g_FileHeader;
static NODE g_Node;
//static NODEHEADER g_NodeHeader;
//static NODEMETADATA g_NodeMetaData;

UINT32 XMFVLQ2Integer(HUGE UINT8 *bData, UINT32 len)
{
  UINT32 lLen = 0;
	UINT8 bDo = 1;
  
	g_bSize = 0;

  if ((len < 1) || ((len < 2) && (*bData >= 0x80)))
	{
			
		return 0;
	}
  if ((len >= 4) &&
      ((*bData == 0) && (*(bData+1) == 0) && (*(bData+2) == 0) && (*(bData+3) == 0)))
	{
			
		return 1;
	}
  
  	g_bSize = 1;    

	lLen = (UINT32)(*bData & 0x7F);

	while((bDo) && (len > 0))
	{
		if (((*bData) & 0x80)>>7 == 1)
		{
			len--;
			if(len == 0)
				return 0;
			bData++;
			g_bSize++;

			lLen = (lLen<<7) + (UINT32)(*bData & 0x7F);
		}
    		else
		{
      			bDo = 0;		 
		}
	}


  return lLen;
}

UINT8 VXmf_Parser(HUGE UINT8 *fp, UINT32 len)
{
	UINT8 	bReturn = 1;
	UINT32 	lNodeContainedItems, lOffset;
	UINT8 	i, j;
	UINT32 	dwDlsLen = 0;
	UINT8 	bSelectNameLen = 0;
	UINT8 	bNameLen = 0;
	UINT32   lLen = 0;
	HUGE UINT8 *ptr;
	HUGE UINT8 *pTemp;
	HUGE UINT8 *pSelectName;
  
	ptr = (HUGE UINT8 *)fp;	
	if (ptr == NULL) return (0);
	if (len == 0) return (0);

	if (len < 22) 
	{
		return (0);
	}

	if ((ptr[0] != 'X') || (ptr[1] != 'M') || (ptr[2] != 'F')
		|| (ptr[4] != '1') || (ptr[5] != '.') || (ptr[6] != '0') ||(ptr[7] != '0'))
	{
		return (0);
	}

	ptr += 8;
	len -= 8;

	g_FileHeader.lFileLen = XMFVLQ2Integer(ptr, len);
	ptr += g_bSize;
	len -= g_bSize;
  
	ptr += ((g_bSize<<1) + 4);                      
	len -= ((g_bSize<<1) + 4);
	
	if (*(ptr+2) == 0x0b) 
	{
		bSelectNameLen = (UINT8)XMFVLQ2Integer(ptr+4, len);
		pSelectName = ptr + 4 + g_bSize;
	}
  
	g_FileHeader.lTreeStart = XMFVLQ2Integer(ptr, len);
	ptr += g_bSize + g_FileHeader.lTreeStart + 2;
	len -= g_bSize + g_FileHeader.lTreeStart + 2;
  
	g_Node.nodeHeader.lNodeLen = XMFVLQ2Integer(ptr, len);
	ptr += g_bSize;
	len -= g_bSize;

	g_Node.nodeHeader.chNodeContainedItems = XMFVLQ2Integer(ptr, len);
	ptr += g_bSize;
	len -= g_bSize;

	g_Node.nodeHeader.lNodeHeaderLen = XMFVLQ2Integer(ptr, len);
	ptr += g_bSize;
	len -= g_bSize;

	lLen = XMFVLQ2Integer(ptr, len);
	ptr += g_bSize;
	len -= g_bSize;

	ptr += lLen + 2;
	len -= lLen + 2;
	lNodeContainedItems = g_Node.nodeHeader.chNodeContainedItems;

	if ((lNodeContainedItems >= 1) && (len > 0) && (g_bSize > 0))
	{
		for(i = 0; i < (int)lNodeContainedItems; i++)
		{
			g_Node.nodeHeader.lNodeLen = XMFVLQ2Integer(ptr, len);
			pTemp = ptr;
			ptr += g_bSize;

			g_Node.nodeHeader.chNodeContainedItems = XMFVLQ2Integer(ptr, len);
			ptr += g_bSize;

			g_Node.nodeHeader.lNodeHeaderLen = XMFVLQ2Integer(ptr, len);
			ptr += g_bSize;

			if (*(ptr+2) == 0x04) 
			{
				bNameLen = (UINT8)XMFVLQ2Integer(ptr+4, len);
				ptr = ptr + 4 + g_bSize;
				if (bNameLen == bSelectNameLen) 
				{
					for(j = 0; j < bNameLen; j++)
					{
						if (*(ptr + j) == *(pSelectName + j)) 
						{
							g_bSelect = i;
						}
						else
						{
							g_bSelect = 0;
							break;
						}
					}
				}
			}

			ptr = pTemp + g_Node.nodeHeader.lNodeHeaderLen;
			len -= g_Node.nodeHeader.lNodeHeaderLen;
			if (*ptr == 1) 
			{
				ptr++;
				len--;
				g_XmfData[i].pXmfData = ptr;
				g_XmfData[i].dwXmfDataLen = g_Node.nodeHeader.lNodeLen - g_Node.nodeHeader.lNodeHeaderLen - 1;	
				ptr += g_XmfData[i].dwXmfDataLen;
				len -= g_XmfData[i].dwXmfDataLen;
			}
      else if (*ptr == 2) 
			{
				ptr++;	
				lOffset = XMFVLQ2Integer(ptr, len);
				ptr += g_bSize;
				g_XmfData[i].pXmfData = ptr + lOffset;
		//		g_XmfData[i].dwXmfDataLen = ??? ;
				//	len -= g_XmfData[i].dwXmfDataLen;
      }
      else if (*ptr == 3) 
			{
				ptr++;
				lOffset = XMFVLQ2Integer((UINT8 *)ptr, len);
				ptr += g_bSize + lOffset;
				len -= g_bSize + lOffset;
				
				g_Node.nodeHeader.lNodeLen = XMFVLQ2Integer(ptr, len);
				pTemp = ptr;				
				ptr += g_bSize;
				len -= g_bSize;

				g_Node.nodeHeader.chNodeContainedItems = XMFVLQ2Integer(ptr, len);
				ptr += g_bSize;
				len -= g_bSize;

				g_Node.nodeHeader.lNodeHeaderLen = XMFVLQ2Integer(ptr, len);
				ptr += g_bSize;
				len -= g_bSize;

				ptr = pTemp + g_Node.nodeHeader.lNodeHeaderLen - 2;
				if (*ptr == 1) 
				{
					ptr++;
					len--;
					g_XmfData[i].pXmfData = ptr;
					g_XmfData[i].dwXmfDataLen = g_Node.nodeHeader.lNodeLen - g_Node.nodeHeader.lNodeHeaderLen - 1;	
					ptr += g_bSize;
				  len -= g_bSize;
				}
				else
					return 0;
      }
			else
				return 0;
		}		
	}
  else
		return 0;

	if ((len > 0) && (*ptr > 0) && (len >= (*ptr)))
	{
		g_Node.nodeHeader.lNodeLen = XMFVLQ2Integer(ptr, len);
		ptr += g_bSize;
		len -= g_bSize;
		pTemp = ptr;
		dwDlsLen += g_bSize;

		g_Node.nodeHeader.chNodeContainedItems = XMFVLQ2Integer(ptr, len);
		ptr += g_bSize;
		len -= g_bSize;
		dwDlsLen += g_bSize;

		g_Node.nodeHeader.lNodeHeaderLen = XMFVLQ2Integer(ptr, len);
		ptr += g_bSize;
		len -= g_bSize;
		g_Node.nodeHeader.lNodeHeaderLen++;
		dwDlsLen += g_bSize + g_Node.nodeHeader.lNodeHeaderLen;
    ptr += g_Node.nodeHeader.lNodeHeaderLen;
    len -= g_Node.nodeHeader.lNodeHeaderLen;

    dwDlsLen += XMFVLQ2Integer(ptr, len)+2;
		ptr +=  XMFVLQ2Integer(ptr, len)+2;

		if (*ptr == 1) 
		{
			ptr++;
			len--;
			dwDlsLen++;
			g_XmfData[0].pDlsData = ptr;
			g_XmfData[0].dwlsDataLen = g_Node.nodeHeader.lNodeLen - dwDlsLen;	
			ptr += g_XmfData[0].dwlsDataLen;
			len -= g_XmfData[0].dwlsDataLen;
		}
    else if (*ptr == 2) 
		{
			ptr++;	
			len--;
			lOffset = XMFVLQ2Integer(ptr, len);
			ptr += g_bSize;
			g_XmfData[0].pDlsData = ptr+lOffset;
	//		g_XmfData[0].dwlsDataLen = ??? ;
    }
    else if (*ptr == 3) 
		{
			ptr++;
			len--;
			lOffset = XMFVLQ2Integer(ptr, len);
			ptr += g_bSize + lOffset;
      len -= g_bSize + lOffset;

			g_Node.nodeHeader.lNodeLen = XMFVLQ2Integer(ptr, len);
			ptr += g_bSize;
			len -= g_bSize;
			pTemp = ptr;

			g_Node.nodeHeader.chNodeContainedItems = XMFVLQ2Integer(ptr, len);
			ptr += g_bSize;
			len -= g_bSize;

			g_Node.nodeHeader.lNodeHeaderLen = XMFVLQ2Integer(ptr, len);
			ptr += g_bSize;
			len -= g_bSize;

			ptr = pTemp + g_Node.nodeHeader.lNodeHeaderLen - 2;
			if (*ptr == 1) 
			{
				ptr++;
			  len--;
				g_XmfData[0].pDlsData = ptr;
				g_XmfData[0].dwlsDataLen = g_Node.nodeHeader.lNodeLen - g_Node.nodeHeader.lNodeHeaderLen - 1;	
				ptr += g_bSize;
				len -= g_bSize;
			}
			else
				return 0;
    }
		else
			return 0;
	}

	return bReturn;	
}

void XMF_SetBeginTime(void)
{
	UINT8 idx, temp;
	UINT32 dwTimeCode;

	for(idx=0; idx<g_TrackNum; idx++)
	{
		temp = *(g_MidiTrack[idx].pCurnData++);
		dwTimeCode = (UINT32)temp&0x7f;
		while((temp&0x80) != 0)
		{
			temp = *(g_MidiTrack[idx].pCurnData);
			dwTimeCode = dwTimeCode*0x80 + (temp&0x7f);
			g_MidiTrack[idx].pCurnData++;
		}

		g_MidiTrack[idx].dwNextTick	+= dwTimeCode;
	}
	return;
}

UINT8 XMF_FindLeastTimeTrack(void)
{
	UINT8 idx, tracknum;
	UINT32 dwMinTick;

	dwMinTick = 0xffffffff;
	tracknum = 0;

	for(idx=0; idx<g_TrackNum; idx++)
	{
		if( ((g_dwTrackEnd>>idx)&0x01) == 0)//track is not end
		{
			if(dwMinTick > g_MidiTrack[idx].dwNextTick)
			{
				dwMinTick = g_MidiTrack[idx].dwNextTick;
				tracknum = idx;
			}
		}
	}
	
	g_dwCurTime += (g_MidiTrack[tracknum].dwNextTick - g_dwCurTick)*g_dwTempoMS;
	g_dwCurTick = g_MidiTrack[tracknum].dwNextTick;

	return tracknum;
}



UINT8 XMF_GetOneMessage(UINT8 TrkNum)
{
	UINT8 msgID, msgLen, msgNum, status, temp;
	UINT32 dwTempoCode, dwTimeCode,i,MELTAlen;
	HUGE UINT8 *pCurData;

	msgNum = 0;
	
	pCurData = (HUGE UINT8*)(g_MidiTrack[TrkNum].pCurnData);
	
	if(pCurData >= g_MidiTrack[TrkNum].pDataEnd)
	{
		g_dwTrackEnd |=((UINT32)0x00000001<<TrkNum);
		
		return msgNum;
	}

	status = *pCurData;

	if( (status&0x80) == 0)//MsgID be omitted
	{
		msgID = (g_MidiTrack[TrkNum].preStatus) & 0xf0;

		switch(msgID)
		{
		case MSG_CHNPRESSURE:
		case MSG_PROGCHANGE:
			msgLen = 1;
			break;
		default:
			msgLen = 2;
			break;
		}

		if(msgLen>0)//write to msgBuf
		{
			*(UINT16*)g_msgBuf = (UINT16)((g_dwCurTime - g_dwPreTime)/1000);
			g_dwPreTime = g_dwCurTime;

			g_msgBuf[2] = g_MidiTrack[TrkNum].preStatus;

			for(i=0; i<msgLen; i++)
			{
				g_msgBuf[3 + i] = *pCurData;
				pCurData++;
			}

			msgNum = 1;
		}
	}
	else
	{
		if(status == MELTA_EVENT)
		{
			pCurData++;
			switch(*pCurData)
			{
			case MELTA_TEMPO:
				pCurData++;
				if(*pCurData != 0x03)
				{
					//Unknown tempo format,was ignored
					MELTAlen = (UINT32)*pCurData;
					for(i=0; i<MELTAlen+1; i++)
						pCurData++;
				}
				else
				{
					dwTempoCode = 0;
					pCurData++;
					for(i=0; i<3; i++)
					{
						dwTempoCode = dwTempoCode*0x100 + *pCurData;
						pCurData++;
					}
					g_dwTempoMS = dwTempoCode/g_dwTicksPerQN;
				}
				msgLen = 0;
				break;

			default:
				//not supported
				if(*pCurData==0x7f)
				{
					pCurData++;
					temp = (*pCurData);
					MELTAlen = (UINT32)(temp&0x7f);
					pCurData++;
					while((temp&0x80) != 0)
					{
						temp = *pCurData;
						MELTAlen = MELTAlen*0x80 + (UINT32)(temp&0x7f);
						pCurData++;
					}
						pCurData--;
				}
				else
				{
					pCurData++;
					MELTAlen = (UINT32)*pCurData;
				}
				for(i=0; i<=MELTAlen; i++)
					pCurData++;
				msgLen = 0;
				break;
			}
		}
		else if(status==MSG_SYSEXCLUDE)
		{
			while(*pCurData != 0xf7)	//no system exclusive message supported
				pCurData++;
			pCurData++;
			msgLen = 0;
		}
		else
		{
			msgID = status&0xf0;
			if(msgID==MSG_PROGCHANGE||msgID==MSG_CHNPRESSURE)
				msgLen = 2;
			else
				msgLen = 3;
		}

		if(msgLen>0)
		{
			*(UINT16*)g_msgBuf = (UINT16)((g_dwCurTime - g_dwPreTime)/1000);
			g_dwPreTime = g_dwCurTime;
			
			g_MidiTrack[TrkNum].preStatus = status;

			for(i=0; i<msgLen; i++)
			{
				g_msgBuf[2 + i] = *pCurData;
				pCurData++;
			}

			msgNum = 1;
		}
	}

	if(pCurData >= g_MidiTrack[TrkNum].pDataEnd)
	{
		g_dwTrackEnd |=((UINT32)0x00000001<<TrkNum);
				
		return msgNum;
	}

	temp = *(pCurData);
	dwTimeCode = temp&0x7f;
	pCurData++;
	while((temp&0x80) != 0)
	{
		temp = *pCurData;
		dwTimeCode = dwTimeCode*0x80 + (temp&0x7f);
		pCurData++;
	}
	g_MidiTrack[TrkNum].dwNextTick += dwTimeCode;
	g_MidiTrack[TrkNum].pCurnData = pCurData;
	return msgNum;
}


VRESULT VXmf_Init()
{
	UINT8 idx;
	g_TrackNum 		= 0;
	g_dwTicksPerQN	= 0;
	g_dwTempoMS		= 0;
	g_dwTrackEnd	= 0xffffffff;
	g_dwPreTime		= 0;
	g_dwCurTime		= 0;
	g_dwCurTick		= 0;
	g_bEndFlag		= 0;
	g_MsgQueNum		= 0;
	g_dwTotalTime	= 0;
	g_SeekOverTime	= 0;

	g_pXmfFilePtr	= NULL;
	g_dwXmfLen		= 0;

	for(idx=0; idx<MAX_MIDI_CHN; idx++)
	{
		g_RPN[idx] = 0x7f7f;
	}
	
	return VRES_SUCCESS;
}

VRESULT VXmf_Load(HUGE UINT8 * fp, UINT32 len, UINT32 dEmptyRes, UINT8 bSrcFlag)
{
	UINT32	dwSize, dwFromat, dwTrackNum;
	UINT32	dwTemp, i, dwTrkNum;
	UINT8   bReturn = 0;
	HUGE UINT8 * ptr;

	bReturn = VXmf_Parser(fp, len);
	if (bReturn == 0) 
    return (VRES_ERROR);

	g_pXmfFilePtr = fp;
	g_dwXmfLen   = len;
	
	len = g_XmfData[g_bSelect].dwXmfDataLen;
	ptr = (HUGE UINT8 *)(g_XmfData[g_bSelect].pXmfData);	

	if (ptr == NULL) return (VRES_ERROR);
	if (len == 0) return (VRES_ERROR);

	if (len < 22) 
	{
		return (VMAMIDI_INVALID_DATA);
	}

	if ((ptr[0] != 'M') || (ptr[1] != 'T') || (ptr[2] != 'h') ||(ptr[3] != 'd'))
	{
		dwSize = ((UINT32)ptr[7] << 24) + ((UINT32)ptr[6] << 16) +
		         ((UINT32)ptr[5] << 8) + (UINT32)ptr[4];
		if (len < (dwSize+8)) 
		{
			return (VMAMIDI_INVALID_DATA);
		}
			
		while(len>=4)
		{
			if((ptr[0]=='d')&&(ptr[1]=='a')&&(ptr[2]=='t')&&(ptr[3]=='a'))
			{
				dwSize = ((UINT32)ptr[7] << 24) + ((UINT32)ptr[6] << 16) +
						((UINT32)ptr[5] << 8) + (UINT32)ptr[4];
				if (len < (dwSize+8)) 
				{
					return (VMAMIDI_INVALID_DATA);
				}
			}

			if((ptr[0]=='M')&&(ptr[1]=='T')&&(ptr[2]=='h')&&(ptr[3]=='d'))
			{
				break;
			}
			else
			{
				ptr++;
				len--;
			}
		
		}
	}

	if(len==4)		//There is no "data"
		return (VMAMIDI_INVALID_DATA);

	//--- File size ----//
	dwSize = ((UINT32)ptr[4] << 24) + ((UINT32)ptr[5] << 16) +
	         ((UINT32)ptr[6] << 8) + (UINT32)ptr[7];
	if (dwSize != 6)
	{
		return (VMAMIDI_INVALID_DATA);
	}

	//--- File format --// only support format =0,1;
	dwFromat = ((UINT32)ptr[8] << 8) + (UINT32)ptr[9];
	if (dwFromat > 1)
	{
		return (VMAMIDI_INVALID_DATA);
	}
	g_MidiFmt = (UINT8)dwFromat;

	//--- Number of tracks ---//
	dwTrackNum = ((UINT32)ptr[10] << 8) + (UINT32)ptr[11];
	if (dwTrackNum == 0)
	{
		return (VMAMIDI_INVALID_DATA);
	}
	if ((dwFromat == 0) && (dwTrackNum != 1))
	{
		return (VMAMIDI_INVALID_DATA);
	}
	

	g_TrackNum = (UINT8)dwTrackNum;
	dwTrkNum = 0;

	//-- Tempo ----//
	dwTemp = ((UINT32)ptr[12] << 8) + (UINT32)ptr[13];
	g_dwTicksPerQN = dwTemp & 0x7fff;
	g_dwTempoMS = TEMPO_CODE/g_dwTicksPerQN;
	if (((dwTemp & 0x8000) != 0) || (g_dwTicksPerQN == 0))
	{
		return (VMAMIDI_INVALID_DATA);
	}

	//--Load tracks--//

	ptr += 14;
	len -= 14;

	for (i = 0; i < g_TrackNum; i++)
	{
		if (len < 8)
		{
			break;
		}
		
		if ((ptr[0] != 'M') ||(ptr[1] != 'T') || (ptr[2] != 'r') ||(ptr[3] != 'k'))
		{
			break;
		}
		
		dwSize = ((UINT32)ptr[4] << 24) + ((UINT32)ptr[5] << 16) +
		         ((UINT32)ptr[6] << 8) + (UINT32)ptr[7];
	
		if (len < (dwSize + 8))
		{
			break;
		}

		if(dwSize > 4)
		{
			if(dwTrkNum>=MAX_MIDITRACK)
				break;
			else
			{
				g_MidiTrack[dwTrkNum].pDataHead 	= (HUGE UINT8*)&ptr[8];
				g_MidiTrack[dwTrkNum].pCurnData 	= g_MidiTrack[dwTrkNum].pDataHead;
				g_MidiTrack[dwTrkNum].pDataEnd   	= g_MidiTrack[dwTrkNum].pDataHead+dwSize;
				g_MidiTrack[dwTrkNum].dwNextTick	= 0;
				g_MidiTrack[dwTrkNum].preStatus	= 0xff;

				g_dwTrackEnd &= ~((UINT32)0x00000001<<dwTrkNum);

				dwTrkNum++;
			}
			ptr += (dwSize + 8);
			len -= (dwSize + 8);	
		}
		else
		{
			ptr += (dwSize + 8);
			len -= (dwSize + 8);
			continue;
		}	
	}

	g_TrackNum = (UINT8)dwTrkNum;

	if(dwTrkNum==0)
		return (VMAMIDI_INVALID_DATA);
	else
		XMF_SetBeginTime();
	
	return VRES_SUCCESS;
}


VRESULT VXmf_GetEvent(PVM_UNI_MSG p, VDEV_FIFO_TYPE FiFoType)
{	
	UINT8 idx, msgNum, status;

	p->sdDeltaTime  = 0;
	p->bMsgID	 = 0;
	p->bChn		 = 0;
	p->dPara1	 = 0;
	p->dPara2	 = 0;
	p->dPara3	 = 0;

	if(g_MsgQueNum)
	{
		p->sdDeltaTime = g_MsgQue[g_MsgQueNum-1].sdDeltaTime;
		p->bMsgID	 = g_MsgQue[g_MsgQueNum-1].bMsgID;
		p->bChn		 = g_MsgQue[g_MsgQueNum-1].bChn;
		p->dPara1	 = g_MsgQue[g_MsgQueNum-1].dPara1;
		p->dPara2	 = g_MsgQue[g_MsgQueNum-1].dPara2;
		p->dPara3	 = g_MsgQue[g_MsgQueNum-1].dPara3;

		g_MsgQueNum--;
		
		return (VRES_SUCCESS);

	}

	msgNum = 0;

	while(msgNum == 0)
	{
		idx = XMF_FindLeastTimeTrack();
			
		msgNum = XMF_GetOneMessage(idx);

		if(g_dwTrackEnd == (UINT32)0xffffffff )
		{	
			if(!g_bEndFlag)
			{
				p->sdDeltaTime = 0;
				p->bMsgID	 = VMD_MSG_EOS_EVENT;
				p->bChn		 = 0;
				p->dPara1	 = 0x7f;
				p->dPara2	 = 0;
				p->dPara3	 = 0;
				g_bEndFlag   = 1;
				return VRES_SUCCESS;
			}
			else
				return VRES_END_FLAG;
			return (VRES_SUCCESS);
		}

	}

	if(g_SeekOverTime)
	{
		p->sdDeltaTime = (UINT16)(*(UINT16*)g_msgBuf) + (UINT16)(g_SeekOverTime);
		g_SeekOverTime = 0;
	}
	else
		p->sdDeltaTime = (UINT16)(*(UINT16*)g_msgBuf);

	p->bChn		= g_msgBuf[2]&0x0f;
	status		= g_msgBuf[2]&0xf0;

	switch(status)
	{
	case MSG_KEYON:
		if (g_msgBuf[4]) //Note on
		{
			p->bMsgID	= VMD_MSG_NOTE_ON;
			p->dPara1	= (UINT32)g_msgBuf[3];
			p->dPara2	= (UINT32)g_msgBuf[4];
		}
		else //Note off
		{
			p->bMsgID	= VMD_MSG_NOTE_OFF;
			p->dPara1	= (UINT32)g_msgBuf[3];
			p->dPara2	= (UINT32)g_msgBuf[4];
		}
		break;

	case MSG_KEYOFF:
		p->bMsgID	= VMD_MSG_NOTE_OFF;
		p->dPara1	= (UINT32)g_msgBuf[3];
		p->dPara2	= (UINT32)g_msgBuf[4];
		break;

	case MSG_PITCHBEND:
		p->bMsgID	= VMD_MSG_PITCH_BEND;
		p->dPara1	= ((UINT32)(g_msgBuf[4]&0x7f)<<7) + (UINT32)(g_msgBuf[3]&0x7f);
		break;

	case MSG_PROGCHANGE:
		p->bMsgID	= VMD_MSG_PROGRAM_CHANGE;
		p->dPara2	= (UINT32)g_msgBuf[3];
		break;

	case MSG_CHNPRESSURE:
		p->bMsgID = VMD_MSG_CHANNEL_PRESSURE;
		p->dPara1	= (UINT32)g_msgBuf[3];
		break;

	case MSG_CTRLCHANGE:
		p->dPara1	= (UINT32)g_msgBuf[4];
		switch(g_msgBuf[3])
		{
		case CTRL_MODULATION:
			p->bMsgID = VMD_MSG_MODULATION_DEPTH;
			break;
		case CTRL_VOLUME:
			p->bMsgID = VMD_MSG_CHANNEL_VOLUME;
			break;
		case CTRL_PANPOT:
			p->bMsgID = VMD_MSG_PANPOT;
			break;
		case CTRL_EXPRESS:
			p->bMsgID = VMD_MSG_EXPRESSION;
			break;
		case CTRL_HOLD1:
			p->bMsgID = VMD_MSG_HOLD1;
			break;
		case CTRL_RESETCTRLS:
			p->bMsgID = VMD_MSG_RESET_ALL_CONTROLLERS;
			g_RPN[p->bChn] = 0x7f7f;
			break;
		case CTRL_ALLNOTEOFF:
			p->bMsgID = VMD_MSG_ALL_NOTE_OFF;
			break;
		case CTRL_RPNLSB:
			g_RPN[p->bChn] = (((UINT16)g_RPN[p->bChn] & 0x7F00) | ((UINT16)g_msgBuf[4]));
			p->bMsgID = VMD_MSG_NOP;
			break;
		case CTRL_RPNMSB:
			g_RPN[p->bChn] = (((UINT16)g_RPN[p->bChn] & 0x007F) | ((UINT16)g_msgBuf[4])<<8);
			p->bMsgID = VMD_MSG_NOP;
			break;
		case CTRL_DATAENTRYMSB:
			if (g_RPN[p->bChn] == 0) 
				p->bMsgID = VMD_MSG_BEND_RANGE;
			else
				p->bMsgID = VMD_MSG_NOP;
			break;

		default:
			p->bMsgID = VMD_MSG_NOP;
			break;
		}
		break;
	}

	g_msgBuf[0] = 0;
	g_msgBuf[1] = 0;
	g_msgBuf[2] = 0;
	g_msgBuf[3] = 0;
	g_msgBuf[4] = 0;

	return (VRES_SUCCESS);
}

VRESULT VXmf_GetFileInfo(PVOID pFileInfo, VDEV_FIFO_TYPE FiFoType)
{
	UINT8 idx;
	FILE_INFO *p;
	UINT32 dwTick, dwTempo, dwTkend, dwPreTime, dwCurTime, dwCurTick;

	p = (FILE_INFO*)pFileInfo;
	
	for(idx=0; idx<g_TrackNum; idx++) //store globle parameters
	{
		g_TrackInfoBak[idx].dwNextTick 	= g_MidiTrack[idx].dwNextTick;
		g_TrackInfoBak[idx].preStatus	  = g_MidiTrack[idx].preStatus;
		g_TrackInfoBak[idx].pCurnData	  = g_MidiTrack[idx].pCurnData;
		g_TrackInfoBak[idx].pDataEnd		= g_MidiTrack[idx].pDataEnd;
		g_TrackInfoBak[idx].pDataHead	  = g_MidiTrack[idx].pDataHead;
	}

	dwTick 		= g_dwTicksPerQN;
	dwTempo 	= g_dwTempoMS;
	dwTkend		= g_dwTrackEnd;
	dwPreTime 	= g_dwPreTime;
	dwCurTime 	= g_dwCurTime;
	dwCurTick	= g_dwCurTick;	

	while(g_dwTrackEnd !=0xffffffff)
	{
		idx = XMF_FindLeastTimeTrack();
		XMF_GetOneMessage(idx);
	}

	p->dTotalTime = g_dwCurTime/1000;
	g_dwTotalTime  = g_dwCurTime;

	for(idx=0; idx<g_TrackNum; idx++)
	{
		g_MidiTrack[idx].dwNextTick 	= g_TrackInfoBak[idx].dwNextTick;
		g_MidiTrack[idx].preStatus		= g_TrackInfoBak[idx].preStatus;
		g_MidiTrack[idx].pCurnData		= g_TrackInfoBak[idx].pCurnData;
		g_MidiTrack[idx].pDataEnd	  	= g_TrackInfoBak[idx].pDataEnd;
		g_MidiTrack[idx].pDataHead		= g_TrackInfoBak[idx].pDataHead;
	}

	g_dwTicksPerQN 	= dwTick;
	g_dwTempoMS 	= dwTempo;
	g_dwTrackEnd 	= dwTkend;
	g_dwPreTime 	= dwPreTime;
	g_dwCurTime 	= dwCurTime;
	g_dwCurTick 	= dwCurTick;

	g_msgBuf[0] = 0;
	g_msgBuf[1] = 0;
	g_msgBuf[2] = 0;
	g_msgBuf[3] = 0;
	g_msgBuf[4] = 0;

	return VRES_SUCCESS;
}


void XMF_SeekMsg()
{
	UINT8 idx, msgNum, status, chn;

	msgNum = 0;

	while(msgNum == 0)
	{
		idx = XMF_FindLeastTimeTrack();
			
		msgNum = XMF_GetOneMessage(idx);

		if(g_dwTrackEnd == 0xffffffff )
			return;
	}

	status = g_msgBuf[2]&0xf0;
	chn = g_msgBuf[2]&0x0f;

	switch(status)
	{
	case MSG_PITCHBEND:
		g_ChnInfo[chn].pitchbendH = g_msgBuf[4]&0x7f;
		g_ChnInfo[chn].pitchbendL = g_msgBuf[3]&0x7f;
		break;

	case MSG_PROGCHANGE:
		g_ChnInfo[chn].timbre = g_msgBuf[3];
		break;

	case MSG_CTRLCHANGE:

		switch(g_msgBuf[3])
		{
		case CTRL_MODULATION:
			g_ChnInfo[chn].modulation = g_msgBuf[4];
			break;
			
		case CTRL_VOLUME:
			g_ChnInfo[chn].volume = g_msgBuf[4];
			break;
			
		case CTRL_PANPOT:
			g_ChnInfo[chn].panpot = g_msgBuf[4];
			break;
			
		case CTRL_EXPRESS:
			g_ChnInfo[chn].expression = g_msgBuf[4];
			break;
			
		case CTRL_HOLD1:
			g_ChnInfo[chn].hold1= g_msgBuf[4];
			break;
			
		case CTRL_RESETCTRLS:
			g_RPN[chn] = 0x7f7f;
			//g_ChnInfo[chn].volume     	= 0x7f;
			g_ChnInfo[chn].expression	= 0x7f;
			g_ChnInfo[chn].modulation 	= 0;
			//g_ChnInfo[chn].bendrange  	= 0x02;  //bendrange= 0x02*100;
			//g_ChnInfo[chn].panpot     	= 0x40;
			g_ChnInfo[chn].hold1      	= 0;

			break;
			
		case CTRL_RPNLSB:
			g_RPN[chn] = ((g_RPN[chn] & 0x7F00) | ((UINT16)g_msgBuf[4]));
			break;
			
		case CTRL_RPNMSB:
			g_RPN[chn] = ((g_RPN[chn] & 0x007F) | ((UINT16)g_msgBuf[4])<<8);
			break;
			
		case CTRL_DATAENTRYMSB:
			if (g_RPN[chn] == 0) 
				g_ChnInfo[chn].bendrange= g_msgBuf[4];
			break;

		default:
			break;
		}

	default:
		break;
	}

	g_msgBuf[0] = 0;
	g_msgBuf[1] = 0;
	g_msgBuf[2] = 0;
	g_msgBuf[3] = 0;
	g_msgBuf[4] = 0;

	return;
}

void XMF_AddMsgQue()
{
	UINT8 chn;
	PVM_UNI_MSG p;

	for(chn=0; chn<MAX_MIDI_CHN; chn++)
	{
		if(g_ChnInfo[chn].timbre != 0)
		{
			p = &g_MsgQue[g_MsgQueNum];
			
			p->bChn = chn;
			p->sdDeltaTime = 0;
			p->bMsgID = VMD_MSG_PROGRAM_CHANGE;
			p->dPara2 = (UINT32)g_ChnInfo[chn].timbre ;
			
			g_MsgQueNum++;
		}

		if(g_ChnInfo[chn].volume != 0x7f)
		{
			p = &g_MsgQue[g_MsgQueNum];
			
			p->bChn = chn;
			p->sdDeltaTime = 0;
			p->bMsgID = VMD_MSG_CHANNEL_VOLUME;
			p->dPara1 = (UINT32)g_ChnInfo[chn].volume ;
			
			g_MsgQueNum++;
		}

		if(g_ChnInfo[chn].expression != 0x7f)
		{
			p = &g_MsgQue[g_MsgQueNum];
			
			p->bChn = chn;
			p->sdDeltaTime = 0;
			p->bMsgID = VMD_MSG_EXPRESSION;
			p->dPara1 = (UINT32)g_ChnInfo[chn].expression ;
			
			g_MsgQueNum++;
		}

		if(g_ChnInfo[chn].modulation != 0)
		{
			p = &g_MsgQue[g_MsgQueNum];
			
			p->bChn = chn;
			p->sdDeltaTime = 0;
			p->bMsgID = VMD_MSG_MODULATION_DEPTH;
			p->dPara1 = (UINT32)g_ChnInfo[chn].modulation ;
			
			g_MsgQueNum++;
		}

		if(g_ChnInfo[chn].pitchbendH != 0x40 ||g_ChnInfo[chn].pitchbendL != 0 )
		{
			p = &g_MsgQue[g_MsgQueNum];
			
			p->bChn = chn;
			p->sdDeltaTime = 0;
			p->bMsgID = VMD_MSG_PITCH_BEND;
			p->dPara1	= ((UINT32)(g_ChnInfo[chn].pitchbendH )<<7) + (UINT32)(g_ChnInfo[chn].pitchbendL);
			
			g_MsgQueNum++;
		}

		if(g_ChnInfo[chn].bendrange != 2)
		{
			p = &g_MsgQue[g_MsgQueNum];
			
			p->bChn = chn;
			p->sdDeltaTime = 0;
			p->bMsgID = VMD_MSG_BEND_RANGE;
			p->dPara1 = (UINT32)g_ChnInfo[chn].bendrange ;
			
			g_MsgQueNum++;
		}

		if(g_ChnInfo[chn].panpot != 0x40)
		{
			p = &g_MsgQue[g_MsgQueNum];
			
			p->bChn = chn;
			p->sdDeltaTime = 0;
			p->bMsgID = VMD_MSG_PANPOT;
			p->dPara1 = (UINT32)g_ChnInfo[chn].panpot ;
			
			g_MsgQueNum++;
		}

		if(g_ChnInfo[chn].hold1 != 0)
		{
			p = &g_MsgQue[g_MsgQueNum];
			
			p->bChn = chn;
			p->sdDeltaTime = 0;
			p->bMsgID = VMD_MSG_HOLD1;
			p->dPara1 = (UINT32)g_ChnInfo[chn].hold1 ;
			
			g_MsgQueNum++;
		}
	}
}



VRESULT	VXmf_Seek(UINT32 pos, VDEV_FIFO_TYPE FiFoType)
{
	UINT8 idx;

	if((pos*1000) >= g_dwTotalTime)
	{
		g_dwTrackEnd = 0xffffffff;
		return VRES_SUCCESS;
	}

	if(!pos)
		return VRES_SUCCESS;

	for(idx=0; idx<MAX_MIDI_CHN; idx++)
	{
		g_ChnInfo[idx].timbre	  	= 0x00;
		g_ChnInfo[idx].volume     	= 0x7f;
		g_ChnInfo[idx].expression 	= 0x7f;
		g_ChnInfo[idx].modulation 	= 0;
		g_ChnInfo[idx].pitchbendH 	= 0x40;
		g_ChnInfo[idx].pitchbendL 	= 0x00;
		g_ChnInfo[idx].bendrange  	= 0x02;  //bendrange= 0x02*100;
		g_ChnInfo[idx].panpot     	= 0x40;
		g_ChnInfo[idx].hold1      	= 0x00;
	}

	while((pos*1000) >= g_dwCurTime)
	{
		XMF_SeekMsg();
	}

	g_SeekOverTime = g_dwCurTime/1000 - pos;
	XMF_AddMsgQue();

	return VRES_SUCCESS;
}

VRESULT VXmf_GetCurPos(UINT32 * PosPtr, VDEV_FIFO_TYPE FiFoType)
{
	*PosPtr = (g_dwCurTime/(1000));
	return VRES_SUCCESS;
}

VRESULT VXmf_Reset(VDEV_FIFO_TYPE FiFoType)
{
	UINT8 	idx;
	
	g_dwTrackEnd	= 0xffffffff;
	g_dwPreTime		= 0;
	g_dwCurTime		= 0;
	g_dwCurTick		= 0;
	g_bEndFlag		= 0;
	g_MsgQueNum		= 0;
	g_SeekOverTime	= 0;

	for(idx=0; idx<MAX_MIDI_CHN; idx++)
	{
		g_RPN[idx] = 0x7f7f;
	}

	VXmf_Load(g_pXmfFilePtr, g_dwXmfLen, 0, 0);

	return VRES_SUCCESS;
}


#endif  //VMD_PARSER_XMF_SUPPORT
